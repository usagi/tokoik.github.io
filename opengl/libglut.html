<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-2022-jp">
<meta http-equiv="Content-Style-Type" content="text/css">
<link rel="stylesheet" type="text/css" href="opengl.css">
<link rev="MADE" href="mailto:tokoi@sys.wakayama-u.ac.jp">
<title>GLUTによる「手抜き」OpenGL入門</title>
</head>

<body>

<h1 class="title">GLUTによる「手抜き」OpenGL入門</h1>
<h3 class="title">
<a href="http://www.wakayama-u.ac.jp/">和歌山大学</a>
<a href="http://www.sys.wakayama-u.ac.jp/">システム工学部</a>
<a href="http://www.sys.wakayama-u.ac.jp/di/">デザイン情報学科</a>
</h3>
<h2 class="title"><a href="mailto:tokoi@sys.wakayama-u.ac.jp">床井浩平</a></h2>

<h3 class="title">この文書の位置づけ</h3>
<blockquote>
この文書は学生実験のテーマ「ＶＲ実験」の参考資料の,
GLUT を用いた OpenGL のチュートリアルです.
180 分&times; 2 日＋&alpha;で実験部分に到達できると思います.
ただし内容は不十分なので,
必要に応じて<a href="#reference">資料</a>やオンラインマニュ
アル等を参照してください.
また間違いも含まれていると思います.
コメントをお願いします.
なお, このページはリンク＆コピーフリーです. このディレクトリをまとめたものを
<a href="http://www.sys.wakayama-u.ac.jp/~tokoi/tenuki.tar.gz">ここ</a>
に用意していますので, ご自由にお使いください.
</blockquote>

<blockquote></blockquote>

<p class="title">
初版 1997/09/30,
最終更新 2016/07/22<br><br>
<span style="color: #844;">この学生実験 (演習) は 2016 年度をもって終了しました. 18 年間 (演習で使用した期間) ありがとうございました.</span>
</p>

<blockquote>
<h3>目次</h3>
<div>　<a href="#1">１．はじめに</a></div>
<div>　　<a href="#1.1">１．１ なぜ GLUT か</a></div>
<div>　　<a href="#1.2">１．２ それ以前に, なぜ OpenGL か</a></div>
<div>　<a href="#2">２．GLUT のインストール</a></div>
<div>　　<a href="#2.1">２．１ GLUT を入手する</a></div>
<div>　　<a href="#2.2">２．２ UNIX 系 OS にインストールする</a></div>
<div>　　<a href="#2.3">２．３ Windows 系 OS にインストールする</a></div>
<div>　　<a href="#2.4">２．４ Mac OS X にインストールする</a></div>
<div>　<a href="#3">３．コンパイルの仕方</a></div>
<div>　　<a href="#3.1">３．１ UNIX 系 OS の場合</a></div>
<div>　　<a href="#3.2">３．２ Windows 系 OS (Visual Studio) の場合</a></div>
<div>　　<a href="#3.3">３．３ Mac OS X (Developer Tools) の場合</a></div>
<div>　<a href="#4">４．ウィンドウを開く</a></div>
<div>　　<a href="#4.1">４．１ 空のウィンドウを開く</a></div>
<div>　　<a href="#4.2">４．２ ウィンドウを塗りつぶす</a></div>
<div>　<a href="#5">５．二次元図形を描く</a></div>
<div>　　<a href="#5.1">５．１ 線を引く</a></div>
<div>　　<a href="#5.2">５．２ 図形のタイプ</a></div>
<div>　　<a href="#5.3">５．３ 線に色を付ける</a></div>
<div>　　<a href="#5.4">５．４ 図形を塗りつぶす</a></div>
<div>　　<a href="#5.5">５．５ 関数の命名法</a></div>
<div>　<a href="#6">６．座標軸を設定する</a></div>
<div>　　<a href="#6.1">６．１ 座標軸とビューポート</a></div>
<div>　　<a href="#6.2">６．２ 位置やサイズを指定してウィンドウを開く</a></div>
<div>　<a href="#7">７．マウスとキーボード</a></div>
<div>　　<a href="#7.1">７．１ マウスボタンをクリックする</a></div>
<div>　　<a href="#7.2">７．２ マウスをドラッグする</a></div>
<div>　　<a href="#7.3">７．３ キーボードから読み込む</a></div>
<div>　<a href="#8">８．三次元図形を描く</a></div>
<div>　　<a href="#8.1">８．１ 二次元と三次元</a></div>
<div>　　<a href="#8.2">８．２ 線画を表示する</a></div>
<div>　　<a href="#8.3">８．３ 透視投影する</a></div>
<div>　　<a href="#8.4">８．４ 視点の位置を変更する</a></div>
<div>　<a href="#9">９．アニメーション</a></div>
<div>　　<a href="#9.1">９．１ 図形を動かす</a></div>
<div>　　<a href="#9.2">９．２ ダブルバッファリング</a></div>
<div><a href="#10">１０．隠面消去処理</a></div>
<div>　<a href="#10.1">１０．１ 多面体を塗りつぶす</a></div>
<div>　<a href="#10.2">１０．２ デプスバッファを使う</a></div>
<div>　<a href="#10.3">１０．３ カリング</a></div>
<div><a href="#11">１１．陰影付け</a></div>
<div>　<a href="#11.1">１１．１ 光を当ててみる</a></div>
<div>　<a href="#11.2">１１．２ 光源を設定する</a></div>
<div>　<a href="#11.3">１１．３ 材質を設定する</a></div>
<div><a href="#12">１２．階層構造</a></div>
<div><a href="#ex1">実験１．基本実験</a></div>
<div><a href="#ex2">実験２．立体視の実験</a></div>
<div><a href="#ex3">実験３．自由課題</a></div>
<!--
<div><a href="#ex3">実験３．仮想のぞき穴の実験</a></div>
<div><a href="#ex4">実験４．仮想パペットの実験</a></div>
<div><a href="#ex5">実験５．仮想パンチングボールの実験</a></div>
-->

<h3><a class="label" name="reference">資料：</a></h3>
<ul>
<li><a href="faq.html">今までにあった質問</a></li>
<li><a href="refresh.html">リフレッシュレートの変更</a></li>
<li><a href="libaux.html">AUX 版</a>, <a href="libglut-old.html">Indy 版</a>, <a href="http://www.kohgakusha.co.jp/books/detail/4-7775-1134-0">書籍版</a></li>
<li><a href="http://www.wakayama-u.ac.jp/~tokoi/">床井研究室</a> (<a href="http://marina.sys.wakayama-u.ac.jp/~tokoi/oglarticles.html">OpenGL 関連記事</a>)</li>
<li><a href="http://www.wakayama-u.ac.jp/~kenshin/">柴山 健伸 先生</a> (<a href="http://www.sys.wakayama-u.ac.jp/">システム工学部</a><a href="http://www.sys.wakayama-u.ac.jp/cc/">情報通信システム学科</a>) の<a href="kenshin/">混沌としたサンプル</a></li>
<li><a href="http://www.wakayama-u.ac.jp/~chen/">陳 謙 先生</a> (<a href="http://www.sys.wakayama-u.ac.jp/">システム工学部</a><a href="http://www.sys.wakayama-u.ac.jp/di/">デザイン情報学科</a>) の <a href="http://www.sys.wakayama-u.ac.jp/~chen/MotifGL.html">Motif を使ったサンプル</a></li>
<li><a href="delphi.html">中山 礼児 氏 (経済学部 2000 年卒) の Delphi についての解説</a></li>
<li><a href="http://www.opengl.org/">The OpenGL WEB Site</a> (OpenGL の総本山)</li>
<li><a href="http://www.opengl.org/resources/libraries/glut/">GLUT - The OpenGL Utility Toolkit</a> (OpenGL.org の GLUT のページ)</li>
<li><a href="http://www.opengl.org/code/">OpenGL Code &amp; Tutorial Listings</a> (OpenGL.org のチュートリアル集)</li>
<li><a href="http://www.opengl.org/resources/faq/technical/">OpenGL Technical FAQ</a> (OpenGL について良く聞かれる質問)</li>
<li><a href="http://opengl.jp/faq/openglfaq.html">OpenGL FAQ 日本語</a> (OpenGL について良く聞かれる質問の日本語版)</li>
<li><a href="http://www.opengl.org/resources/libraries/glut/spec3/spec3.html">GLUT Programming Interface API Version 3</a> (GLUT のマニュアル)</li>
<li><a href="http://opengl.jp/glut/"> GLUT (OpenGL Utility Toolkit) ガイド 日本語版</a> (上記の邦訳)</li>
<li><a href="http://www.opengl.org/resources/libraries/glut/faq/">GLUT FAQ</a> (GLUT について良く聞かれる質問)</li>
<li><a href="http://developer.apple.com/library/mac/#samplecode/glut/Introduction/Intro.html">GLUT for Mac OS X</a> (Mac OS X の GLUT のソースプログラム)</li>
<li><a href="http://www.exa-corp.co.jp/">株式会社エクサ</a>さんの<a href="http://www.exa-corp.co.jp/solutions/ubiquitous/ubiquitous-solution/">
OpenGL プログラミングコース</a> (本格的な教材・公開に感謝)</li>
<li><a href="http://wisdom.sakura.ne.jp/">WisdomSoft (赤坂玲音)</a> さんの <a href="http://wisdom.sakura.ne.jp/system/opengl/">OpenGL 入門</a> (系統立てて構成された優れたテキスト)</li>
<li><a href="http://mail2.nara-edu.ac.jp/~asait/">数学と計算</a> (OpenGL のほか, C/C++, LaTeX 等豊富なチュートリアルあり)</li>
<li><a href="http://son-son.sakura.ne.jp/mt/blog/">sonson@Picture&amp;Software</a> (GLUT に頼らない OpenGL の使い方等詳しい解説がある)</li>
<li><a href="http://wiki.livedoor.jp/mikk_ni3_92/">OpenGL de プログラミング</a> (基礎から最新技術・周辺技術まで網羅的にまとまっている)</li>
<li><a href="http://asura.iaigiri.com/">☆PROJECT ASURA☆</a> (<a href="http://asura.iaigiri.com/program.html">[PROGRAM]</a> のページに優れた解説とサンプルがたくさんある)</li>
<li><a href="http://www.natural-science.or.jp/laboratory/opengl_intro.php">コンピュータ・シミュレーション講座 OpenGL 入門</a> (natural science Laboratory)</li>
<li><a href="https://github.com/toruwest/jogl-tutorial-document">JOGL (Java 版 OpenGL)  のチュートリアル</a> (この「手抜き OpenGL」をもとに作成されました)</li>
<li><a href="http://opengl.jp/ml/">OpenGL Mailing List</a> (日本の OpenGL エキスパートが集う)</li>
</ul>
</blockquote>

<h2><a class="label" name="1">１．はじめに</a></h2>

<h3><a class="label" name="1.1">１．１ なぜ GLUT か</a></h3>

<p>OpenGL は Silicon Graphics 社 (現 SGI 社, 以下 SGI) が開発した,
<em>OS に依存しない</em>三次元のグラフィックスライブラリ
(正確には Application Program Interface, API) です.
でも, この「OS に依存しない」というところが実は曲者で,
ウィンドウを開いたりマウスの操作を受け付けたりするところは,
それぞれの OS の流儀に則って,
OS やウィンドウシステムにお願いしないといけません.
すなわち, OpenGL の機能を使えるようにするためには, 
Windows なら Windows の, X Window なら X Window のやり方で,
あらかじめお膳立てをしてやる必要があるのです.</p>

<p>実はこれが結構面倒な作業なので, 教科書の
<a href="http://fly.srk.fer.hr/%7eunreal/theredbook/">
OpenGL Programming Guide の第 1 版</a>
では, 補助ライブラリ (AUX ライブラリ, 一種のツールキット) というのを導入して,
その部分をとりあえず隠していました.
つまり, AUX ライブラリに OS に依存する処理を任せることで,
読者は OpenGL
そのものの学習に専念できるようになっていたのです.</p>

<blockquote>
OpenGL Programming Guide の第 2 版以降では,
AUX ライブラリに代えて GLUT を使っています.
</blockquote>

<p>ところで, Microsoft 社 (以下 MS) が
SGI から OpenGL のライセンスを買って自分のところの OS に載っけたので,
OpenGL は一気にグラフィックスライブラリの<em>業界標準</em>の地位に登り詰めました.
その際, この AUX ライブラリも Windows (NT / 95) に移植されました.
この結果, 図らずも? この AUX ライブラリを使って書いたソースプログラムは,
UNIX と Windows のどちらでもコンパイルできるという便利な仕組みができ上がりました.</p>

<p>しかし, AUX ライブラリはもともと学習用であり,
ちゃんとしたアプリケーションを書こうとすると機能に不足を感じます.
それに MS による AUX ライブラリの移植はやはり MS の流儀で行われていて,
例えばイベントのハンドラには
CALLBACK という型を付けないといけないとか,
やっぱり気色の悪い部分があったりします.</p>

<p>そこで AUX ライブラリを,
多少なりともまともなアプリケーションが作れるように改良したものが
GLUT (The OpenGL Utilitiy Toolkit) だと言えます.
これは SGI の Mark Kilgard 氏によって作成されました
(今は NVIDIA に居るみたいですけど).
またユタ大学の Nate Robins 氏 (この人も今は
NVIDIA に居るらしい) という人によって,
Windows にも移植されました.
このため GLUT には AUX ライブラリのような問題?はありません.
バージョン 3.6 以降では Windows 版と UNIX 版のソースコードが統合され,
まとめて提供されています.</p>

<blockquote>
Linux や Macintosh では <a href="#Mesa">Mesa</a> の上に AUX
ライブラリや GLUT が移植されました. また Apple 自身もついに?
Mac OS 8.1 から <a href="http://developer.apple.com/opengl/">OpenGL</a>
を採用し, この上でも GLUT が使用可能になりました.
現在の Mac OS X ではグラフィックス機能の基盤として OpenGL を採用しており,
Developer Tools (Xcode) には標準で GLUT が含まれています.
ソースプログラムも公開されています
(<a href="http://developer.apple.com/library/mac/#samplecode/glut/Introduction/Intro.html">GLUT for Mac OS X</a>).
いくつかデモプログラムも入っています.
</blockquote>

<h3><a class="label" name="1.2">１．２ それ以前に, なぜ OpenGL か</a></h3>

<p>シミュレーション結果の視覚化など,
グラフィックスを専門としない人が
グラフィックスプログラミングをしなければならないということは結構ありますよね.
私の記憶が正しければ, かつて (いつの話だ?) は
Calcomp のプロッタライブラリとか, Tektronix 4014
ターミナルのエスケープシーケンスとか, あるいは
N88BASIC のグラフィックス (GLIO 呼び出しとか) 
なんかがそういう目的に使われてたように思います.</p>

<p>現在なら, そういう目的には何を使えばいいのでしょうか?
Windows ならもちろん DirectX に含まれる Direct3D (D3D) が使えます.
X Window なら Xlib で書くしかないのでしょうか?
PEX はもう廃れましたよね?
こういうものは, 使ったことがある人はわかると思いますが,
実際に絵を描き始めるまでに訳の分からない呪文をいっぱい並べないといけなかったりして,
結構煩わしいもんですよね.
特にグラフィックスとなると&#133;</p>

<p>本格的な GUI (Graphical User Interface)
を持ったアプリケーションプログラムを作りたければ,
Windows なら素直に Visual BASIC を使うか,
MFC (Microsoft Foundation Class) あるいは
.Net なんかを使うべきでしょう.
X Window なら Motif や GTK などのツールキットを使えば見栄えのいいものができると思います.
でも, これらはあくまで「ユーザーインタフェース構築のための部品集」なので,
これら自体はあまり「グラフィックスプログラミング」の役に立ちそうにありません.</p>

<p>OpenGL は三次元のグラフィックスライブラリですが,
もちろん二次元の機能も持っています.
なにより, これを使うと N88BASIC の
LINE 文で図形を書いていた頃 (遠くなったなぁ) の気楽さで
グラフィックスプログラミングができます (あくまで個人的な印象です).
それでいて,  (当たり前だけど) 
N88BASIC とは比較にならないほどいろんなことができます.</p>

<p>ということで, OpenGL と GLUT を組み合わせれば, </p>

<ol>
<li>UNIX 系 OS (Linux, FreeBSD 等を含む) と Windows と Mac のいずれでも動く, </li>
<li>リアルタイムに三次元表示を行うプログラムが, </li>
<li>とっても簡単に書けてしまう, </li>
</ol>

<p>という三拍子そろったメリットが得られます.</p>

<blockquote>iPhone OS や Android では,
OpenGL から派生した OpenGL ES が使われています.</blockquote>

<p>もちろん GLUT は,
本格的な GUI を持ったプログラムの開発には向いていません.
しかし研究などで,
手早くグラフィックスのプログラムを仕上げないといけないという場合には,
とても便利な組み合わせだと思います.</p>

<p>なお GUI については, オリジナルの GLUT 自体にも一応
<a href="http://www.sgi.com/products/software/opengl/examples/glut/mui/">mui (micro-UI)</a>
というツールキットが含まれています.
このほか, <a href="http://glui.sourceforge.net/">GLUI</a>
という GLUT と C++ で書かれたツールキットがリリースされています.
これについては,
<a href="http://ktm11.eng.shizuoka.ac.jp/glui/">
GLUIリファレンスマニュアル日本語版</a>
に日本語で書かれた詳しい資料があります. また 
<a href="http://www.clutter-project.org/">Clutter</a> という
OpenGL のほかに OpenGL ES でも使用できるマルチプラットホームの
ツールキットも開発されています.</p>

<p>これらと同様にマルチプラットホームで使えるツールキットとして,
<a href="http://qt.nokia.com/title-jp/">Qt</a> (&quot;キュート&quot; と読む) や
<a href="http://www.fltk.org/">FLTK (Fast Light Toolkit)</a>,
<a href="http://www.glfw.org/">GLFW</a>,
<a href="http://www.libsdl.org/">SDL (Simple Directmedia Layer)</a>
などがあります.
Qt は最近のグラフィックスアプリケーションの
GUI ツールキットとして非常に人気があります.
非常に高機能ですが, 非常に巨大です.
FLTK は GUI に特化していますが, 非常に軽量です.
GLFW はマウスやキーボードのほか, ジョイスティックも入力デバイスとして使えます.
SDL はジョイスティックなどの入力機器に加えて, 音声も扱うことができます.
一方, Linux などで使われる GTK というツールキットをベースにしたものに,
<a href="http://linux.maruhn.com/sec/gtkglarea.html">GtkGLArea</a> や
<a href="http://gtkglext.sourceforge.net/">GtkGLExt</a>
があります.
その他の OpenGL と組み合わせて使えるツールキットについては,
<a href="http://www.opengl.org">OpenGL.org</a> の
<a href="http://www.opengl.org/resources/libraries/windowtoolkits/">
GLUT-like Windowing Toolkits</a> に紹介があります.</p>

<h2><a class="label" name="2">２．GLUT をインストールする</a></h2>

<h3><a class="label" name="2.1">２．１ GLUT を入手する</a></h3>

<p>オリジナルの GLUT のソースファイルの場所は
<a href="http://www.opengl.org/resources/libraries/glut/">GLUT - The OpenGL Utility Toolkit</a>
のページからたどることができます
(<a href="http://www.opengl.org/resources/libraries/glut/glut-3.7.tar.gz">glut-3.7.tar.gz</a>
/ <a href="http://www.opengl.org/resources/libraries/glut/glut37.zip">glut37.zip</a> と
<a href="http://www.opengl.org/resources/libraries/glut/glut_data-3.7.tar.gz">glut_data-3.7.tar.gz</a>
/ <a href="http://www.opengl.org/resources/libraries/glut/glut37data.zip">glut37data.zip</a>).
ただし, オリジナルの GLUT は, 1998 年に発表された Version 3.7 以来, 長い間メンテナンスされていません.
現在では, 代わりに <a href="http://freeglut.sourceforge.net/">freeglut</a>
という互換のツールキットが使用されることが多いようです
(他に
<a href="http://openglut.sourceforge.net/">OpenGLUT</a>
というものもありますが, これも現在メンテナンスされていないようです).</p>

<h3><a class="label" name="2.2">２．２ UNIX / Linux 系 OS にインストールする</a></h3>

<p>ほとんどの Linux / FreeBSD 系の OS には,
GLUT (おそらく freeglut) のパッケージが用意されていると思います.
使用する OS のパッケージマネージャを使ってインストールしてください.</p>

<pre class="source"><span class="gray">(Vine)</span>
$ sudo apt-get install freeglut freeglut-devel
<span class="gray">(Debian, Ubuntu)</span>
$ sudo apt-get install freeglut3 freeglut3-dev
<span class="gray">(RedHat, Fedra)</span>
$ sudo yum install freeglut
$ sudo yum install freeglut-devel</pre>

<p>root の権限がないときは,
<a href="http://freeglut.sourceforge.net/">freeglut</a>
のソースを入手して, 自分でコンパイルしてください.
freeglut のバージョン <em>3</em> 以降では, これに cmake を使います (渡辺 敏暢 様 情報ありがとうございました).
cmake の使い方は,
<a href="http://www.wakayama-u.ac.jp/~chen/">陳 先生</a>が「<a href="http://www.wakayama-u.ac.jp/~chen/cmake/cmake.html">CMake
の勧め</a>」で説明されています (陳 先生 ありがとうございます).
下記の &quot;インストール先&quot; には,
自分が書き込み可能なディレクトリを指定してください.
&quot;-DCMAKE_INSTALL_PREFIX=インストール先&quot; を省略した場合は,
make install により /usr/local 以下にインストールされます.</p>

<pre class="source">$ tar xzf freeglut-<em>3</em>.Y.Z.tar.gz
$ cd freeglut-<em>3</em>.Y.Z
$ mkdir build
$ cd build
$ cmake -DCMAKE_INSTALL_PREFIX=<em>インストール先</em> ..
$ make
$ make install</pre>

<p>ここでもし &quot;XInput.h が無い&quot; というエラーでビルドに失敗するときは,
freeglut-3.Y.Z/src/x11 にある fg_internal_x11.h の中で #include している
X11/extensions/<em>XInput.h</em> を X11/extensions/<em>XI.h</em> に書き換えてください.</p>

<p>一方, freeglut のバージョン <em>2</em> では,
ソースプログラムに含まれている configure スクリプトを使います.
下記の &quot;インストール先&quot; には,
自分が書き込み可能なディレクトリを指定してください.
&quot;--prefix=インストール先&quot; を省略した場合は,
make install により /usr/local 以下にインストールされます.</p>

<pre class="source">$ tar xzf freeglut-<em>2</em>.Y.Z.tar.gz
$ cd freeglut-<em>2</em>.Y.Z
$ ./configure --prefix=<em>インストール先</em>
$ make
$ make install</pre>

<p>オリジナルの GLUT をインストールする場合は,
<a href="http://www.opengl.org/resources/libraries/glut/">GLUT - The OpenGL Utility Toolkit</a>
のページからソースファイル
(<a href="http://www.opengl.org/resources/libraries/glut/glut-3.7.tar.gz">glut-3.7.tar.gz</a>,
<a href="http://www.opengl.org/resources/libraries/glut/glut_data-3.7.tar.gz">glut_data-3.7.tar.gz</a>)
を取ってきてコンパイルしてください.
ただし, このコンパイルに使用する xmkmf や imake は現在の
X Window には含まれていないので,
別に入手してインストールしておく必要があります.
また, その際は glut-3.7/lib/glut に cd して make したほうがいいでしょう.
glut-3.7 で make するとサンプルプログラムから何からコンパイルするので,
すごく時間がかかります (非常に参考になるサンプルプログラムなので,
目を通しておくことを勧めます).</p>

<pre class="source">$ gunzip -d -c glut-3.7.tar.gz | tar xf -
$ cd glut-3.7
$ xmkmf
$ make Makefiles
$ make includes
$ make depend
$ cd lib/glut
$ make</pre>

<p>上記の手順により glut-3.7/lib/glut/libglut.a が作成されます.
これと glut-3.7/include/GL/glut.h を,
GLUT を用いて作成するプログラムと同じディレクトリか,
他の適当なディレクトリに置いてください.</p>

<h4><a class="label" name="Mesa">Mesa について</a></h4>
<p>Linux などメーカーによって OpenGL が移植されていない UNIX 系 OS では,
<a href="http://www.mesa3d.org/">Mesa</a>
と呼ばれる OpenGL 互換のライブラリが X Window に組み込まれています.
このソースプログラムは,
<a href="http://sourceforge.net/projects/mesa3d">SourceForge の
Mesa3D プロジェクト</a>から入手できます.</p>

<blockquote>SGI から Mark Kilgard
氏を含む大量のエンジニアが
<a href="http://www.nvidia.com/">NVIDIA</a> に移籍したと思ったら,
1999 年 2 月には SGI が GLX (X Window の OpenGL 拡張)
をオープンソース化</a>して,
<a href="http://www.xfree86.org/">XFree86</a> や
<a href="http://www.x.org/">X.Org</a> でも
GLX が使えるようになりました.
現在 <a href="http://www.nvidia.com/">NVIDIA</a> や
<a href="http://www.amd.com/">AMD (ATI)</a>
などのグラフィックスプロセッサメーカーが,
OpenGL のハードウェアアクセラレーションが有効なドライバを提供しています.
その他のメーカーも,
それぞれにドライバを用意しているようです.</blockquote>

<blockquote>ただし,
メーカーから提供されるドライバ (プロプライエタリドライバ) の中には,
OS のカーネルを &quot;汚染&quot; するものがあるため,
Linux のパッケージに標準的に含まれることはないようです.
オープンソースのドライバについては,
<a href="http://dri.sourceforge.net/">DRI
(Direct Rendering Infrastracture)</a>
などを参照してください. また
<a href="http://utah-glx.sourceforge.net/">Utah-GLX</a>
にもいくつかのグラフィックスプロセッサのドライバがあります.
ところで SGI は 2000 年の 1 月，ついに 
<a href="http://oss.sgi.com/projects/ogl-sample/">
OpenGL のサンプルインプリメンテーションをオープンソース化</a>してしまいました.
</blockquote>

<h3><a class="label" name="2.3">２．３ Windows 系 OS にインストールする</A></h3>

<p>OpenGL が使えるのは, OpenGL の DLL をインストールした Windows 95 および
Windows 98 以降の OS です.
Windows 95 の場合,
OSR2 以降なら多分標準で入っているのではないかと思いますが,
無い場合は MS からダウンロードしてきてください.
これは<a href="ftp://ftp.microsoft.com/softlib/MSLFILES/opengl95.exe">
ftp://ftp.microsoft.com/softlib/MSLFILES/opengl95.exe</a>
にあります (いまさら Windows 95 を使うことは無いと思いますが).</p>

<p>GLUT を使えるようにするには,
以前は Nate Robins 氏が Windows 用のバイナリファイルを提供されていましたが,
現在はすでに提供を終了されているようです.
ここでは <a href="http://freeglut.sourceforge.net/">freeglut</a>
をコンパイルして使う方法を説明します.
開発環境は Visual Studio 2013 を想定しています.</p>

<ol>
  <li>freeglut はバージョン 3 から CMake を使用して作成するようになっています. 
  freeglut のインストールに先立ち, CMake の Windows 用バイナリのインストーラを入手してください.
  <a href="http://www.cmake.org/">CMake のサイト</a>の &quot;Download the Latest Version of CMake&quot;
  のボタンをクリックして, &quot;Binary distributions:&quot; の &quot;Windows (Win32 Installer)&quot;
  を選んでください.</li>
  <li>CMake のインストーラを起動してインストールしてください.</li>
  <li>次に,
  <a href="http://freeglut.sourceforge.net/index.php#download">freeglut のソースファイル</a>を入手します.
  これは .tar.gz 形式のアーカイブファイルなので,
  <a href="http://www.forest.impress.co.jp/lib/arc/archive/archiver/lhaplus.html">lhaplus</a>
  などの適当なアーカイバを使って展開してください.</li>
  <li>CMake (cmake-gui) を起動し,
  &quot;Browse Source&quot; をクリックして
  freeglut のソースファイルを展開したディレクトリを選んでください.てください.
  <div class="figure"><img src="cmake0.png" width="682" height="623" alt="CMake"></div></li>
  <li>&quot;Browse Build&quot; をクリックして, コンパイルしたバイナリファイルを置くディレクトリを選んでください.
  これはソースファイルのディレクトリの下に &quot;build&quot; というフォルダを作成することが一般的のようです.
  <div class="figure"><img src="cmake1.png" width="387" height="332" alt="ビルド先の指定"></div></li>
  <li>&quot;Configure&quot; をクリックします.
  <div class="figure"><img src="cmake2.png" width="682" height="623" alt="CMake の Configure"></div></li>
  <li>すると, 使用する開発環境を尋ねられます. ここでは Visual Studio 2013 を使用し,
  32bit 版のライブラリファイルを作成することにします.
    <div class="figure"><img src="cmake3.png" width="516" height="399" alt="使用する開発環境の指定"></div></li>
  <li>最後に &quot;Generate&quot; をクリックすれば, Visual Studio 2013 のソリューションファイルファイルが作成されます.
  <div class="figure"><img src="cmake4.png" width="682" height="623" alt="ソリューションファイルの作成"></div></li>
  <li>Visual Studio 2013 のソリューションファイルファイル <em>freeglut.sln</em> は,
  &quot;Browse Build&quot; に指定したフォルダに作成されます. Visual Studio 2013 でこれを開いてください.</li>
  <li>演習のプログラムは, とりあえず Debug モードで作成すると思いますから,
    「構成マネージャ」の「アクティブ ソリューション 構成」は
    &quot;<em>Debug</em>&quot; のままにしておいてください.</li>
  <li>「アクティブ ショリューション プラットフォーム」は
  &quot;<em>Win32</em>&quot; を選んでください.
  64 ビット版のライブラリを作成する場合は,
  CMake の Configure 時に 64 ビット版のライブラリファイルの作成を指定する必要があります.
  CMake の Configure を最初からやり直すには,
  cmake-gui の &quot;File&quot; メニューの &quot;Delete Cache&quot; を選んでください.</li>
  <li>Visual Studio 2013 の「ビルド」メニューの「ソリューションのビルド」を選んでください.
  ビルドに成功すれば, CMake の &quot;Browse Build&quot; に指定したフォルダの中の
  &quot;bin&quot; と &quot;lib&quot; フォルダの下にライブラリファイルが作成されます.</li>
  <li>&quot;bin&quot; フォルダの &quot;Debug&quot; フォルダの中にある freeglutd.dll,
  および &quot;lib&quot; フォルダの &quot;Debug&quot; フォルダの中にある freeglutd.lib と freeglut_staticd.lib というファイルを,
  使用する開発環境に応じて, それぞれ次の場所にコピーします.
    <dl>
      <dt>freeglutd.lib, freeglut_staticd.lib</dt>
      <dd>
        <ul>
          <li>OS が 32 ビット版なら
            <ul>
              <li>&quot;C:\Program Files\Windows Kits\8.1\Lib\winv6.3\um\x86&quot;</li>
            </ul>
          </li>
          <li>OS が 64 ビット版なら
            <ul>
              <li>Win32 版は &quot;C:\Program Files (x86)\Windows Kits\8.1\Lib\winv6.3\um\x86&quot;</li>
              <li>x64 版は &quot;C:\Program Files (x86)\Windows Kits\8.1\Lib\winv6.3\um\x64&quot;</li>
            </ul>
          </li>
        </ul>
      </dd>
      <dt>freeglutd.dll</dt>
      <dd>
        <ul>
          <li>OS が 32 ビット版なら
            <ul>
              <li>&quot;C:\Windows\System32&quot;</li>
            </ul>
          </li>
          <li>OS が 64 ビット版なら
            <ul>
              <li>Win32 版の DLL は &quot;C:\Windows\SysWOW64&quot;</li>
              <li>x64 版の DLL は &quot;C:\Windows\System32&quot;</li>
            </ul>
            <strong>(64 ビット版 OS の &quot;C:\Windows\System32&quot; には 64 ビット版の DLL を入れます)</strong>
          </li>
        </ul>
      </dd>
    </dl>
  自分のプログラムを Release 
  ビルドする可能性がある場合は, Visual Studio 2013 の「アクティブ ソリューション 構成」を &quot;Release&quot; に切り替えて, freeglut を Release ビルドしてください. &quot;bin&quot; フォルダと &quot;lib&quot; フォルダのそれぞれの &quot;Release&quot; フォルダの下に freeglut.dll および freeglut.lib, freeglut_static.lib が作成されますから, これらを上記と同じ場所にコピーしてください.</li>
  <li>展開した freeglut のフォルダにある &quot;include&quot; フォルダの中の &quot;GL&quot; フォルダにあるヘッダファイルを下記の場所にコピーします.
    <dl>
      <dt>glut.h freeglut.h freeglut_std.h freeglut_ext.h</dt>
      <dd>
        <ul>
          <li>OS が 32 ビット版なら
            <ul>
              <li>&quot;C:\Program Files\Windows Kits\8.1\Include\um\gl&quot;</li>
            </ul>
          </li>
          <li>OS が 64 ビット版なら
            <ul>
              <li>&quot;C:\Program Files (x86)\Windows Kits\8.1\Include\um\gl&quot;</li>
            </ul>
          </li>
        </ul>
      </dd>
    </dl>
  </li>
</ol>

<p> C++ Builder の場合は &quot;えむっち&quot; さんの
  <a href="http://www.nk.rim.or.jp/~m_iida/programming/diary/19990421.html">
へっぽこ<span style="text-decoration: line-through">プログラマー</span>日記</a>が参考になります.
Cygwin の場合は
<a href="http://pitecan.com/info/winglut.html">
Cygwin で OpenGL / Glut を使う方法</a>で詳しく解説されています.
また, フリーの処理系の
<a href="http://www.cs.virginia.edu/~lcc-win32/">LCC-Win32</a>
というのも使えるそうです
(<a href="http://www.cc.rim.or.jp/~yukkun/glut.html">Using GLUT
with LCC-Win32</a>, 山本 秀一 先生 ご教示ありがとうございました).
この他, 埼玉大学の櫻井 先生が OpenGL と GLUT を Windows9*/NT で使う方法について
<a href="http://www.rimath.saitama-u.ac.jp/lab.jp/tsakurai/opengl/index.html">
OpenGL の部屋</a>に詳しくおまとめになっています.</p>
<h3><a class="label" name="2.4">２．４ Mac OS X にインストールする</A></h3>

<p>Mac OS X では標準で OpenGL と GLUT が使えます.
OS に標準で添付されている Developer Tools をインストールしてください.
GLUT は Developer Tools に含まれています.
ソースプログラムも公開されています
(<a href="http://developer.apple.com/library/mac/#samplecode/glut/Introduction/Intro.html">GLUT for Mac OS X</a>).
ただし,
<em>この Web
ページのソースプログラムをそのままコンパイルできるようにするため</em>には,
/usr/local/include に GL というディレクトリを掘って,
そこに GLUT のソースファイルに含まれている glut.h をコピーするか,
そこから /System/Library/Frameworks/GLUT.framework/Headers/glut.h
へのシンボリックリンクを張っておく必要があります.</p>

<pre class="source">$ sudo mkdir /usr/local/include
$ sudo mkdir /usr/local/include/GL
$ cd /usr/local/include/GL
$ sudo ln -s /System/Library/Frameworks/GLUT.framework/Headers/glut.h .</pre>

<p>この最後のシンボリックリンクを<em>作成しない場合</em>は, 
以下のソースプログラムにおいて <strong>GL</strong>/glut.h ではなく
<strong>GLUT</strong>/glut.h
を #include するようにしてください (Mac OS X ではそうするのがスジでしょう).</p>

<p>ところで, Mac OS X 10.9 (Mavericks) / Xcode 5 以降で GLUT を使ったプログラムをコンパイルすると,
&quot;<em>deplicated</em>&quot; (非推奨) という警告が出ます.
このメッセージは以下の方法で抑制できます.</p>
<ul>
<li>Xcode 5 のプロジェクトの Build Settings で, OS X Deployment Target として OS X 10.8 以前を選ぶ.</li>
<li>コマンドラインでは -mmacosx-version-min=10.8 というオプションを追加するか,
環境変数 MACOSX_DEPLOYMENT_TARGET に 10.8 を設定しておく.</li>
<li>あるいは, コマンドラインに -Wdeprecated-declarations というオプションを追加する.</li>
</ul>
<p>しかし, Mac OS X では OpenGL の Core Profile
(OpenGL 3.2 より前の古い機能との互換性を維持しないモード)
の使用を推奨しており,
<em>Compatibility Mode に依存した GLUT はもう使うべきではない</em>のかも知れません.
なお, GLUT の代替として使用できる
<a href="http://www.glfw.org/">GLFW</a>
は Mac OS X でも使用でき, Core Profile も選択できます.</p>

<p>このほか, Mac OS X 上の X Window 環境である
<a href="http://xquartz.macosforge.org/">XQuartz</a> も
GLX (OpenGL Extension) をサポートしており,
この上でも OpenGL を使うことができます. GLUT も含まれています.
freeglut を使用する場合は, 
<a href="#2.2">２．２</a>と同様にソースからコンパイルしてください.</p>

<h2><a class="label" name="3">３．コンパイルの仕方</a></h2>

<h3><a class="label" name="3.1">３．１ UNIX / Linux 系 OS の場合</a></h3>

<p>freeglut の場合は, cc (あるいは gcc) コマンドに -lglut -lGLU -lGL
というオプションを追加するだけでコンパイルできます.
この演習では, このほかに三角関数などの数学ライブラリも使用するので,
さらに -lm というオプションも付ける必要があります.</p>

<pre class="source">$ cc program.c -lglut -lGLU -lGL -lm</pre>

<p>オリジナルの GLUT の場合は,
以下のようなオプションを付ける必要があるかもしれません
(使う可能性のあるライブラリを全部並べたので,
環境によっては不必要なものも含まれています).</p>

<pre class="source">$ cc -I/usr/X11R6/include program.c -L/usr/X11R6/lib -lglut -lGLU -lGL -lXmu -lXi -lXext -lX11 -lm -lpthread</pre>

<p>GLUT のソースをコンパイルした場合は, 上のコマンドにおいて
glut.h と libglut.a を置いた場所をオプションで指定してください.
仮に, これらを作成するプログラムと同じディレクトリに置いたとすれば,
&quot;<span style="font-family: monospace;">-I. -L.</span>&quot;
というオプションを追加します.</p>

<p>コンパイルの度に長いコマンドを打つのは面倒だと感じたら,
楽をする方法を考えましょう. これにはいくつかの方法が考えられます.</p>

<h4>シェルの関数を定義する</h4>
<p>あらかじめ以下のようなコマンドを実行しておきます.</p>
<pre class="source">$ function ccgl() { cc -I/usr/X11R6/include &quot;$@&quot; -L/usr/X11R6/lib -lglut -lGLU -lGL -lXmu -lXi -lXext -lX11 -lm -lpthread; }</pre>
<p>そうすると, 以降は以下のコマンドでコンパイル (＆リンク) が行えます.</p>
<pre class="source">$ ccgl program.c</pre>
<p>これを .bashrc の中に書いておけば, ログインする度に
alias コマンドを実行する手間が省けます.</p>
<h4>シェルスクリプトを書く</h4>
<p>以下のような内容のファイル ccgl を作成してください.</p>
<pre class="source">#!/bin/sh
exec cc -I/usr/X11R6/include &quot;$@&quot; -L/usr/X11R6/lib -lglut -lGLU -lGL -lXmu -lXi -lXext -lX11 -lm -lpthread</pre>
<p>そのあと chmod コマンドを実行して, このシェルスクリプトを実行可能にします.</p>
<pre class="source">$ chmod +x ccgl</pre>
<p>以降はこの ccgl コマンドを使ってコンパイルできます.</p>
<pre class="source">$ ./ccgl program.c</pre>
<h4>Makefile を作る</h4>
<p>以下の内容の Makefile というファイルを作ります.
&quot;<kbd>--Tab--&gt;</kbd>&quot; のところは,
タブ (Tab) を使って字下げしてください.</p>
<pre class="source">CFLAGS = -I/usr/X11R6/include
LDLIBS = -L/usr/X11R6/lib -lglut -lGLU -lGL -lXmu -lXi -lXext -lX11 -lm -lpthread
a.out: program.c
<kbd>--Tab--&gt;</kbd>$(CC) $(CFLAGS) program.c $(LDLIBS)</pre>
<p>Makefile のあるディレクトリで make コマンドを実行すると,
program.c がコンパイルされて a.out という実行ファイルが生成されます.
なお, $(CC) は cc (または gcc) コマンドに置き換わります. なお, この場合 $(CC) の行は, 実は<em>書かなくても大丈夫</em>です．</p>
<pre class="source">$ make</pre>
<p>このコマンドは emacs の中からも M-x compile で起動できます.</p>

<p>Makefile にはファイルの「生成規則」を記述します.
make は実行すると, Makefile 中の最初の生成規則を探します.
上のファイルの場合, a.out の行がそれになります.
この行には a.out というターゲットを生成するのに program.c
が必要だという依存関係を記述しており,
その次の行に実際に a.out を生成するための手続きを記述しています
(<a href="make.html">注</a>).
この行の行頭は Tab 文字にしてください.</p>

<p>ターゲットが複数あるときは以下のようにします.</p>

<pre class="source">CFLAGS = -I/usr/X11R6/include
LDLIBS = -L/usr/X11R6/lib -lglut -lGLU -lGL -lXmu -lXi -lXext -lX11 -lm -lpthread
all: prog1 prog2
prog1: prog1.c
<kbd>--Tab--&gt;</kbd>$(CC) $(CFLAGS) prog1.c -o prog1 $(LDLIBS)
prog2: prog2.c
<kbd>--Tab--&gt;</kbd>$(CC) $(CFLAGS) prog2.c -o prog2 $(LDLIBS)</pre>

<p>この最初の生成規則は all の行で, all を生成するには prog1 と prog2
が必要だという依存関係を記述しています.
しかし all の生成方法は記述していないので, make は prog1 と prog2
の両方の生成だけが完了した時点で終了します.
特定のターゲットだけを生成したいときは,
そのターゲット名を make の引数に指定します.</p>

<pre class="source">$ make prog1</pre>

<h3><a class="label" name="3.2">３．２ Windows 系 OS (Visual Studio) の場合</A></h3>

<p>プロジェクトを新規作成する際に「Win32 コンソール アプリケーション」を選び, 
「空のプロジェクト」を作成してください.
Visual Studio の使い方を知らない人は,
まず<a href="vs2008/">こちら (Visual Studio 2008)</a>
か<a href="vsnet/">こちら (Visual Studio .NET 2003)</a>
あるいは<a href="vcpp/">こちら (Visual C++ 6.0)</a> を見てください．</p>

<blockquote>
以降で示すプログラムは, UNIX / Linux 系 OS 上での実行を前提に作成しています.
Windows 上では「Win32 コンソール アプリケーション」のプロジェクトにすることで,
これらのプログラムをそのまま Visual Studio 2008 でコンパイルできるようになります.
プログラムの実行時にコンソールウィンドウを開きたくない場合は, ソースプログラムの先頭に次の 1 行を入れてください.</blockquote>

<pre class="source">#pragma comment(linker, &quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;)</pre>

<p>freeglut あるいは GLUT 3.7.2 以降と Visual Studio
の組合わせなら, ソースファイルで GL/glut.h を #include することで, 自動的に freeglut.lib または
glut32.lib, glu32.lib, および opengl32.lib
がリンクされます (山下 真 様 ご教示ありがとうございました).
したがって, このままビルドすれば実行ファイルができあがるはずです.</p>

<blockquote>もしうまくいかないようなら, プロジェクトのプロパティ (Alt+F7) を開き, 「構成プロパティ」の「リンカ」の「入力」を選んで, 「追加の依存ファイル」に freeglut.lib または glut32.lib, glu32.lib, および opengl32.lib の三つを追加してください. このほか, 「C/C++」の「プリプロセッサ」を選んで, 「プリプロセッサの定義」に WIN32 が含まれていることを確かめてください (無いことは無いと思いますが). もしなければ追加してください.</blockquote>

<h3><a class="label" name="3.3">３．３ Mac OS X (Developer Tools) の場合</a></h3>
<p>プログラムをコマンドラインでコンパイルする場合は, cc (あるいは
  gcc) コマンドに以下のようなオプションを付けてください
(榎本 剛 様 ご教示ありがとうございました).
</p>

<pre class="source">$ cc program.c -framework GLUT -framework OpenGL</pre>

<blockquote>Mac OS X 10.9 (Maverics) 以降では,
GLUT を使用したプログラムはコンパイル時に警告が出ます.
この警告を抑制するには,
-mmacosx-version-min=10.8 というオプションを追加してください.</blockquote>

<p>できた a.out を実行すれば, ウィンドウが開きます.
メニューも付いているはずです
(メニューからスクリーンショットの保存ができると思います).</p>

<p>Developer Tools に含まれる Xcode を使う場合は,
既に用意されている GLUT
のサンプルプログラムの (結合) プロジェクトにターゲットを追加するのが,
一番手っ取り早いように思います.
新たにプロジェクトを起こす場合は, 次のような手順になります.</p>
<ol>
<li>新規プロジェクトとして空のプロジェクトを作成する.</li>
<li>新規ターゲットとしてアプリケーションを追加する.</li>
<li>GLUT.framework および OpenGL.framework の二つのフレームワークを追加する.</li>
<li>ソースファイルを作成あるいは追加する.</li>
<li>ビルドする.</li>
</ol>

<p>詳しくは<a href="xcode3.html">ここ (Xcode 3)</a>
か<a href="xcode/">ここ (Xcode)</a>,
あるいは<a href="macosx/">ここ (Project Builder)</a>
を参照してください. なお, <a href="#2.4">２．４</a>で示したように
/usr/local/include/GL 等に glut.h を<strong>置いていない場合</strong>は,
ヘッダファイルとして <strong>GL</strong>/glut.h
ではなく <strong>GLUT</strong>/glut.h
を #include してください.</p>

<p>上記の手順が面倒な場合は,
<a href="http://marina.sys.wakayama-u.ac.jp/~tokoi/sample/GLUT_Application.zip">このファイル</a>を展開してできる &quot;GLUT Application&quot;
というフォルダを /Developer/Library/Xcode/Project Templates/Application というフォルダに入れれば,
Xcode 3 で新規プロジェクトを作成するときに,
&quot;Application&quot; のところに &quot;GLUT Application&quot; が現れます.
ただし, これは見よう見まねで作ったので,
<em>正しいのかどうかわかりません</em>.</p>

<p>Mac OS X 上で X Window (X11) 用にプログラムをコンパイルするには,
<a href="#3.1">３．１</a>で述べた UNIX 系 OS の場合に準じます.
cc コマンドに以下のオプションを追加してください.</p>

<pre class="source">$ cc -I/usr/X11R6/include program.c -L/usr/X11R6/lib -lglut -lGLU -lGL</pre>

<h2><a class="label" name="4">４．ウィンドウを開く</a></h2>

<h3><a class="label" name="4.1">４．１ 空のウィンドウを開く</a></h3>

<p>いよいよプログラムの作成に入ります.
ウィンドウを開くだけのプログラムは,
GLUT を使うとこんな風になります.
このソースプログラムを prog1.c とというファイル名で作成し,
<a href="#3">コンパイル</a>して出来上がった実行プログラム
(a.out) を実行してみてください.</p>

<pre class="source"><em>#include &lt;GL/glut.h&gt;

void display(void)
{
}

int main(int argc, char *argv[])
{
  glutInit(&amp;argc, argv);
  glutCreateWindow(argv[0]);
  glutDisplayFunc(display);
  glutMainLoop();
  return 0;
}</em></pre>

<dl>
<dt><code>void glutInit(int *argcp, char **argv)</code></dt>

<dd>GLUT および OpenGL 環境を初期化します.
引数には main の引数をそのまま渡します.
X Window で使われるオプション -display などはここで処理されます.
この関数によって引数の内容が変更されます.
プログラム自身で処理すべき引数があるときは,
この後で処理します.</dd>

<dt><code>int glutCreateWindow(char *name)</code></dt>

<dd>ウィンドウを開きます.
引数 name はそのウィンドウの名前の文字列で,
タイトルバーなどに表示されます.
以降の OpenGL による図形の描画等は,
開いたウィンドウに対して行われます.
なお, 戻り値は開いたウィンドウの識別子です.</dd>

<dt><code>void glutDisplayFunc(void (*func)(void))</code></dt>

<dd>引数 func は開いたウィンドウ内に描画する関数へのポインタです.
ウィンドウが開かれたり,
他のウィンドウによって隠されたウィンドウが再び現れたりして,
ウィンドウを再描画する必要があるときに,
この関数が実行されます.
したがって, この関数内で図形表示を行います.</dd>

<dt><code>void glutMainLoop(void)</code></dt>

<dd>これは無限ループです.
この関数を呼び出すことで,
プログラムはイベントの待ち受け状態になります.</dd>

</dl>

<p>見れば分かる通り, プログラムは, </p>

<ol>
<li>初期化して, </li>
<li>ウィンドウを開いて, </li>
<li>そのウィンドウ内に絵を描く関数を決めて, </li>
<li>何かことが起こるのを待つ.</li>
</ol>

<p>という順になります.
C 言語の教科書なんかに良く出てくる
「標準入出力を使ったプログラム」なんかと違うところは,
中心となる処理 (この場合 display()) を実行するタイミングが,
ソースプログラムを見ただけでは何時なのかわからない,
というところでしょうか.</p>

<p>最初に display() が実行されるのは,
初めてウィンドウが開いたとき, すなわち,
glutMainLoop() が glutCreateWindow()
の指示を受けてウィンドウの生成を完了したときになります.
また, その後も,
このウィンドウがほかのウィンドウに隠され再び現れたときのように,
ウィンドウの再描画が必要になったときに実行されます.</p>

<p>上のプログラムでは display() の中身に何も記述していないため,
display() が呼び出されても何も仕事をしません.
試しにこのウィンドウを移動したり,
他のウィンドウで隠したりしてみてください.
ウィンドウの中の表示はおかしなものになっていると思います.</p>

<p>このように複数の
(オーバーラップ可能な) 
ウィンドウが使用できるウィンドウシステムに対応したプログラムでは,
処理の流れは時間軸に沿って「プログラムの始めから終りへ」ではなく,
何かこと (事象) が起るたびに「プログラムの各部がランダムに」実行されます.
従って, そのプログラミングスタイルも,
「事象」に対して, その「対処方法」を登録していくというものになります.
ここではこの事象を<em>イベント</em>と呼び,
対処方法の手続きを<em>ハンドラ</em>と呼ぶことにします.</p>

<p>なお, このプログラムには「終了する方法」を組み込んでいないので,
プログラムを終了するには実行したウィンドウで Ctrl-C をタイプするか,
ウィンドウを閉じてください.</p>

<h3><a class="label" name="4.2">４．２ ウィンドウを塗りつぶす</a></h3>

<p>今までは関数 display() の中に何も記述していなかったので,
ウィンドウの中身はでたらめ
(おそらく, そのウィンドウの位置に以前に描かれていた内容の残骸) 
だと思います.
そこで, 今度は開いたウィンドウを塗りつぶしてみます.
prog1.c に<em>太字</em>のところを追加し,
もう一度コンパイルしてプログラムを実行してみてください.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

void display(void)
{
  <em>glClear(GL_COLOR_BUFFER_BIT);</em>
  <em>glFlush();</em>
}

<em>void init(void)
{
  glClearColor(0.0, 0.0, 1.0, 1.0);
}</em>

int main(int argc, char *argv[])
{
  glutInit(&amp;argc, argv);
  <em>glutInitDisplayMode(GLUT_RGBA);</em>
  glutCreateWindow(argv[0]);
  glutDisplayFunc(display);
  <em>init();</em>
  glutMainLoop();
  return 0;
}</pre>

<dl>

<dt><code>void glutInitDisplayMode(unsigned int mode)</code></dt>

<dd>ディスプレイの表示モードを設定します.
mode に GLUT_RGBA を指定した場合は,
色の指定を RGB (赤緑青, 光の三原色) で行えるようにします.
他にインデックスカラーモード (GLUT_INDEX) も指定できます.
後者はうまく使えば効率の良い表示が行えますが,
それなりに面倒なので,
ここではお任せで使える RGBA モードを使います.</dd>

<dt><code>void glClearColor(GLclampf R, GLclampf G, GLclampf B, GLclampf A)</code></dt>

<dd>glClear(GL_COLOR_BUFFER_BIT)
でウィンドウを塗りつぶす際の色を指定します.
R，G，B はそれぞれ赤, 緑, 青色の成分の強さを示す GLclampf 型
(float 型と等価) の値で,
0〜1 の間の値を持ちます.
1 が最も明るく, この三つに (0, 0, 0)
を指定すれば黒色, (1, 1, 1) を指定すれば白色になります.
上の例ではウィンドウは<span class="blue">青色</span>で塗りつぶされます.
最後の A は&alpha;値と呼ばれ, OpenGL では不透明度として扱われます
(0 で透明, 1 で不透明). ここではとりあえず
1 にしておいてください.</dd>

<dt><code><a class="label" name="glClear">void glClear(GLbitfield mask)</a></code></dt>

<dd>ウィンドウを塗りつぶします.
mask には塗りつぶすバッファを指定します.
OpenGL が管理する画面上のバッファ (メモリ) には,
色を格納するカラーバッファの他,
隠面消去処理に使うデプスバッファ,
凝ったことをするときに使うステンシルバッファ,
カラーバッファの上に重ねて表示されるオーバーレイバッファなど,
いくつかのものがあり,
これらが一つのウィンドウに重なって存在しています.
mask に GL_COLOR_BUFFER_BIT を指定したときは,
カラーバッファだけが塗りつぶされます.</dd>

<dt><code>glFlush(void)</code></dt>

<dd>glFlush() はまだ実行されていない OpenGL の命令を全部実行します.
OpenGL は関数呼び出しによって生成される OpenGL
の命令をその都度実行するのではなく,
いくつか溜め込んでおいてまとめて実行します.
このため, ある程度命令が溜まらないと
関数を呼び出しても実行が開始されない場合があります.
glFlush() はそういう状況で
まだ実行されていない残りの命令の実行を開始します.
ひんぱんに glFlush() を呼び出すと, かえって描画速度が低下します.</dd>

</dl>

<p>glClearColor() は,
プログラムの実行中に背景色を変更することがなければ,
最初に一度だけ設定すれば十分です.
そこでこのような初期化処理を行う関数は,
glMainLoop() の前に実行する関数 init()
にまとめて置くことにします.</p>

<p>glFlush() のかわりに glFinish() を使う場合もあります. これは,
glFlush() がまだ実行されていない OpenGL の命令の実行開始を促すのに加えて,
glFinish() はそれがすべて完了するのを待ちます.</p>

<p>gl*() で始まる (glu*() や glut*() で始まらない) 関数が,
OpenGL の API です.</p>

<h2><a class="label" name="5">５．二次元図形を描く</a></h2>

<h3><a class="label" name="5.1">５．１ 線を引く</a></h3>

<p>ウィンドウ内に線を引いてみます.
prog1.c を以下のように変更し,
コンパイルしてプログラムを実行してください.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

void display(void)
{
  glClear(GL_COLOR_BUFFER_BIT);
  <em>glBegin(GL_LINE_LOOP);</em>
  <em>glVertex2d(-0.9, -0.9);</em>
  <em>glVertex2d(0.9, -0.9);</em>
  <em>glVertex2d(0.9, 0.9);</em>
  <em>glVertex2d(-0.9, 0.9);</em>
  <em>glEnd();</em>
  glFlush();
}

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  /* 変更なし */
}</pre>

<dl>

<dt><code>void glBegin(GLnum mode)</code></dt>
<dt><code>void glEnd(void)</code></dt>

<dd>図形を描くには,
glBegin()〜glEnd() の間にその図形の各頂点の座標値を設定する関数を置きます.
glBegin() の引数 mode には描画する図形のタイプを指定します.</dd>

<dt><code><a class="label" name="glVertex2d">void glVertex2d(GLdouble x, GLdouble y)</a></code></dt>

<dd>glVertex2d() は二次元の座標値を設定するのに使います.
引数の型は GLdouble  (double と等価) です.
引数が float 型のときは glVertex2f(),
int 型のときは glVertex2i() を使います.</dd>

</dl>

<p>描かれる図形は, (-0.9, -0.9) と (0.9, 0.9) の 2 点を対角線とする正方形です.
これがウィンドウに対して「一回り小さく」描かれます.
このウィンドウの大きさと図形の大きさの比率は,
ウィンドウを各台縮小しても変化しません.
これはウィンドウの x 軸と y 軸の範囲が,
ともに [-1, 1] に固定されているからです.</p>

<div class="figure"><img src="resize.gif" width="396" height="172" alt="ウィンドウの拡大縮小"></div>

<h3><a class="label" name="5.2">５．２ 図形のタイプ</a></h3>

<p>glBegin() の引数 mode
に指定できる図形のタイプには以下のようなものがあります.
詳しくは man glBegin を参照してください.</p>

<dl>
<dt><code>GL_POINTS</code></dt>
<dd>点を打ちます.</dd>
<dt><code>GL_LINES</code></dt>
<dd>2 点を対にして, その間を直線で結びます.</dd>
<dt><code>GL_LINE_STRIP</code></dt>
<dd>折れ線を描きます.</dd>
<dt><code>GL_LINE_LOOP</code></dt>
<dd>折れ線を描きます. 始点と終点の間も結ばれます.</dd>
<dt><code>GL_TRIANGLES / GL_QUADS</code></dt>
<dd>3 / 4 点を組にして, 三角形 / 四角形を描きます.</dd>
<dt><code>GL_TRIANGLE_STRIP / GL_QUAD_STRIP</code></dt>
<dd>一辺を共有しながら帯状に三角形／四角形を描きます.</dd>
<dt><code>GL_TRIANGLE_FAN</code></dt>
<dd>一辺を共有しながら扇状に三角形を描きます.</dd>
<dt><code>GL_POLYGON</code></dt>
<dd>凸多角形を描きます.</dd>
</dl>
<div class="figure"><img src="libaux1.gif" width="511" height="445"
alt="図形プリミティブ一覧"></div>

<p>OpenGL を処理するハードウェアは,
実際には三角形しか塗り潰すことができません
(モノによっては四角形もできるものもあります).
このため GL_POLYGON の場合は,
多角形を三角形に分割してから処理します.
従って, もし描画速度が重要なら
GL_TRIANGLE_STRIP や GL_TRIANGLE_FAN を使うよう
プログラムを工夫してみてください.
また GL_QUADS も GL_POLYGON より高速です.</p>

<h3><a class="label" name="5.3">５．３ 線に色を付ける</a></h3>

<p>線に色を付けてみます.
prog1.c を以下のように変更し, コンパイルしてください.
プログラムを実行したら線は何色で表示されたでしょうか?</p>

<pre class="source">#include &lt;GL/glut.h&gt;

void display(void)
{
  glClear(GL_COLOR_BUFFER_BIT);
  <em>glColor3d(1.0, 0.0, 0.0);</em>
  glBegin(GL_LINE_LOOP);
  glVertex2d(-0.9, -0.9);
  glVertex2d(0.9, -0.9);
  glVertex2d(0.9, 0.9);
  glVertex2d(-0.9, 0.9);
  glEnd();
  glFlush();
}

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  /* 変更なし */
}</pre>

<dl>

<dt><code><a class="label" name="glColor3d">void glColor3d(GLdouble r, GLdouble g, GLdouble b)</a></code></dt>

<dd>glColor3d() はこれから描画するものの色を指定します.
引数の型は GLdouble 型 (double と等価) で,
r，g，b にはそれぞれ赤, 緑, 青の強さを 0〜1 の範囲で指定します.
引数が float 型のときは glColor3f(),
int 型のときは glColor3i() を使います.</dd>

</dl>

<h3><a class="label" name="5.4">５．４ 図形を塗りつぶす</a></h3>

<p>図形を塗りつぶしてみます.
GL_LINE_LOOP を GL_POLYGON に変更し,
ついでに背景も白色に変更しましょう.
変更したプログラムをコンパイルして実行してください.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

void display(void)
{
  glClear(GL_COLOR_BUFFER_BIT);
  glColor3d(1.0, 0.0, 0.0);
  glBegin(<em>GL_POLYGON</em>);
  glVertex2d(-0.9, -0.9);
  glVertex2d(0.9, -0.9);
  glVertex2d(0.9, 0.9);
  glVertex2d(-0.9, 0.9);
  glEnd();
  glFlush();
}

void init(void)
{
  glClearColor(<em>1.0</em>, <em>1.0</em>, 1.0, 1.0);
}

int main(int argc, char *argv[])
{
  /* 変更なし */
}</pre>

<p>色は頂点毎に指定することもできます.
glBegin() の前の glColor3d() を消して, 
かわりに四つの glVertex2d() の前に glColor3d() を置きます.
prog1.c を以下のように変更してください.
コンパイルしてプログラムを実行すると,
どういう色の付き方になったでしょうか?</p>

<pre class="source">#include &lt;GL/glut.h&gt;

void display(void)
{
  glClear(GL_COLOR_BUFFER_BIT);
  glBegin(GL_POLYGON);
  <em>glColor3d(1.0, 0.0, 0.0); /* 赤 */</em>
  glVertex2d(-0.9, -0.9);
  <em>glColor3d(0.0, 1.0, 0.0); /* 緑 */</em>
  glVertex2d(0.9, -0.9);
  <em>glColor3d(0.0, 0.0, 1.0); /* 青 */</em>
  glVertex2d(0.9, 0.9);
  <em>glColor3d(1.0, 1.0, 0.0); /* 黄 */</em>
  glVertex2d(-0.9, 0.9);
  glEnd();
  glFlush();
}

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  /* 変更なし */
}</pre>

<p>多分,
多角形の内部は頂点の色から補間した色で塗りつぶされたと思います.
このプログラムは後で使用するので,
prog2.c というコピーを作っておいてください.</p>

<pre class="source">$ cp prog1.c prog2.c</pre>

<h3><a class="label" name="5.5">５．５ 関数の命名法</a></h3>

<p>glVertex*() や glColor*() のような関数の * の部分は,
引数の型や数などを示しています.
詳しくは man glVertex2d や man glColor3d を参照してください.</p>

<div class="figure"><img src="libaux2.gif" width="472" height="211"
alt="関数の命名法概略図"></div>

<h2><a class="label" name="6">６．座標軸を設定する</a></h2>

<h3><a class="label" name="6.1">６．１ 座標軸とビューポート</a></h3>

<p>ウィンドウ内に表示する図形の座標軸は,
そのウィンドウ自体の大きさと図形表示を行う &quot;空間&quot; との関係で決定します.
開いたウィンドウの位置や大きさはマウスを使って変更することができますが,
その情報はウィンドウマネージャを通じて,
イベントとしてプログラムに伝えられます.</p>

<p>これまでのプログラムでは,
ウィンドウのサイズを変更すると表示内容もそれにつれて拡大縮小していました.
これを表示内容の大きさを変えずに表示領域のみを広げるようにします.</p>

<p>prog1.c に以下のように resize() という関数を追加し,
glutReshapeFunc() を使って
それをウィンドウのリサイズ (拡大縮小) のイベントに対するハンドラに指定します.
プログラムが変更できたらコンパイルしてプログラムを実行し,
開いたウィンドウを拡大縮小してみてください.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

void display(void)
{
  /* 変更なし */
}

<em>void resize(int w, int h)
{
  /* ウィンドウ全体をビューポートにする */
  glViewport(0, 0, w, h);

  /* 変換行列の初期化 */
  glLoadIdentity();

  /* スクリーン上の表示領域をビューポートの大きさに比例させる */
  glOrtho(-w / 200.0, w / 200.0, -h / 200.0, h / 200.0, -1.0, 1.0);
}</em>

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  glutInit(&amp;argc, argv);
  glutInitDisplayMode(GLUT_RGBA);
  glutCreateWindow(argv[0]);
  glutDisplayFunc(display);
  <em>glutReshapeFunc(resize);</em>
  init();
  glutMainLoop();
  return 0;
}</pre>

<dl>

<dt><code><a class="label" name="glViewport">void glViewport(GLint x, GLint y, GLsizei w, GLsizei h)</a></code></dt>

<dd>ビューポートを設定します.
ビューポートとは, 開いたウィンドウの中で,
実際に描画が行われる領域のことをいいます.
正規化デバイス座標系の 2 点 (-1, -1), (1, 1)
を結ぶ線分を対角線とする矩形領域がここに表示されます.
最初の二つの引数 x, y にはその領域の左下隅の位置,
w には幅, h には高さをデバイス座標系での値,
すなわちディスプレイ上の画素数で指定します.
関数 resize() の引数 w, h にはそれぞれウィンドウの幅と高さが入っていますから,
glViewport(0, 0, w, h)
はリサイズ後のウィンドウの全面を表示領域に使うことになります.</dd>

<dt><code>void glLoadIdentity(void)</code></dt>

<dd>これは変換行列に単位行列を設定します.
座標変換の合成は行列の積で表されますから,
変換行列には初期値として単位行列を設定しておきます.</dd>

<dt><code>void glOrtho(GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f)</code></dt>

<dd>glOrtho() はワールド座標系を正規化デバイス座標系に平行投影
(orthographic projection : 正射影)
する行列を変換行列に乗じます.
引数には左から,
l に表示領域の左端 (left) の位置,
r に右端 (right) の位置,
b に下端 (bottom) の位置,
t に上端 (top) の位置,
n に前方面 (near) の位置,
f に後方面 (far) の位置を指定します.
これは, ビューポートに表示される空間の座標軸を設定します.</dd>

<dt><code>glutReshapeFunc(void (*func)(int w, int h))</code></dt>

<dd>引数 func には,
ウィンドウがリサイズされたときに実行する関数のポインタを与えます.
この関数の引数にはリサイズ後のウィンドウの幅と高さが渡されます.</dd>

</dl>

<p>resize() の処理によって, プログラムは
glViewport() で指定した領域に glOrtho()
で指定した領域内の図形を表示するようになります. ここで glOrtho()
で指定するの領域の大きさをビューポートの大きさに比例するように設定すれば,
表示内容の大きさをビューポートの大きさにかかわらず一定に保つことができます.
ここでビューポートの大きさは開いたウィンドウの大きさと一致させていますから,
ウィンドウのリサイズしても表示内容の大きさを一定に保つことができます.</p>

<div class="figure"><img src="libglut4.gif" width="487" height="227"
alt="ウィンドウ−ビューポート変換"></div>

<p>図形はワールド座標系と呼ばれる空間にあり,
その 2 点 (l, b), (r, t) を結ぶ線分を対角線とする矩形領域を,
2 点 (-1, -1), (1, 1) を対角線とする矩形領域に投影します.
この投影された座標系を正規化デバイス座標系 (あるいはクリッピング座標系) と呼びます.</p>

<p>この正規化デバイス座標系の正方形領域内の図形がデバイス座標系
(ディスプレイ上の表示領域の座標系) のビューポートに表示されますから,
結果的にワールド座標系から glOrtho()
で指定した矩形領域を切り取ってビューポートに表示することになります.</p>

<p>ワールド座標系から切り取る領域は,
&quot;ＣＧ用語&quot; 的には「ウィンドウ」と呼ばれ,
ワールド座標系から正規化デバイス座標系への変換は
「ウィンドウイング変換」と呼ばれます.
しかしウィンドウシステム (X Window, MS Windows 等) においては,
「ウィンドウ」はアプリケーションプログラムが
ディスプレイ上に作成する表示領域のことを指すので,
ここの説明ではこれを「座標軸」と呼んでいます.
なお, 正規化デバイス座標系からデバイス座標系への変換はビューポート変換と呼ばれます.</p>

<p>glOrtho() では引数として l, r, t, b の他に n と f
も指定する必要があります.
実は OpenGL は二次元図形の表示においても内部的に三次元の処理を行っており,
ワールド座標系は奥行き (Z) 方向にも軸を持つ三次元空間になっています.
n と f には,
それぞれこの空間の前方面 (可視範囲の手前側の限界) 
と後方面 (可視範囲の遠方の限界) を指定します.
n より手前にある面や f より遠方にある面は表示されません.</p>

<p>二次元図形は奥行き (Z) 方向が 0 の三次元図形として取り扱われるので,
ここでは n (前方面, 可視範囲の手前の位置) を -1.0,
f  (後方面, 遠方の位置) を 1 にしています.</p>

<p>glOrtho() を使用しなければ変換行列は単位行列のままなので,
ワールド座標系と正規化デバイス座標系は一致し,
ワールド座標系の 2 点 (-1, -1), (1, 1)
を対角線とする矩形領域がビューポートに表示されます.
ビューポート内に表示する空間の座標軸が変化しないため,
この状態でウィンドウのサイズを変化させると,
それに応じて表示される図形のサイズも変わります.
初期状態はこのようになっています.</p>

<p>表示図形のサイズをビューポートの大きさにかかわらず一定にするには, glOrtho()
で指定するの領域の大きさをビューポートの大きさに比例するように設定します.
例えばワールド座標系の座標軸が上記と同様に
l, r, t, b, n, f で与えられており, もともとのウィンドウの大きさが
W&times;H, リサイズ後のウィンドウの大きさが w&times;h
なら, glOrtho(l * w / W, r * w / W, b * h / H, t * h / H, n, f)
とします.
上のプログラムでは,
ワールド座標系の 2 点 (-1, -1), (1, 1)
を対角線とする矩形領域を 200&times;200
の大きさのウィンドウに表示した時の表示内容の大きさが
常に保たれるよう設定しています.</p>

<h3><a class="label" name="6.2">６．２ 位置やサイズを指定してウィンドウを開く</a></h3>

<p>プログラムの起動時に開くウィンドウの位置やサイズを指定したいときは,
glutInitWindowPosition() および glutInitWindowSize()
を使います.
これらを使用しなければ,
プログラムが起動したときに開かれるウィンドウのサイズは
ウィンドウマネージャの設定に従います.
prog1.c に試しに太字の部分を追加してみてください.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

void display(void)
{
  /* 変更なし */
}

void resize(int w, int h)
{
  /* 変更なし */
}

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  <em>glutInitWindowPosition(100, 100);</em>
  <em>glutInitWindowSize(320, 240);</em>
  glutInit(&amp;argc, argv);
  glutInitDisplayMode(GLUT_RGBA);
  glutCreateWindow(argv[0]);
  glutDisplayFunc(display);
  glutReshapeFunc(resize);
  init();
  glutMainLoop();
  return 0;
}</pre>

<dl>

<dt><code>void glutInitWindowSize(int w, int h)</code></dt>

<dd>新たに開くウィンドウの幅と高さを指定します.
これを指定しないときは, 300&times;300 のウィンドウを開きます.</dd>

<dt><code>void glutInitWindowPosition(int x, int y)</code></dt>

<dd>新たに開くウィンドウの位置を指定します.
これを指定しないときは,
ウィンドウマネージャによってウィンドウを開く位置を決定します.</dd>

</dl>

<p>X Window の場合,
-geometry オプションによって
コマンドラインからウィンドウを開く位置やサイズを指定できます.
これは glutInit() によって処理されるので,
-geometry オプションを有効にするには
glutInitWindowPosition() と glutInitWindowSize() を 
glutInit() より前に置き, 無効にするには後に置きます.</p>

<h2><a class="label" name="7">７．マウスとキーボード</a></h2>

<h3><a class="label" name="7.1">７．１ マウスボタンをクリックする</a></h3>

<p>マウスのボタンを押したことを知るには,
glutMouseFunc() という関数で
マウスのボタンを操作したときに呼び出す関数を指定します.
prog1.c を以下のように変更してください.</p>

<pre class="source"><em>#include &lt;stdio.h&gt;</em>
#include &lt;GL/glut.h&gt;

void display(void)
{
  glClear(GL_COLOR_BUFFER_BIT);
  <em>/* 途中削除 */</em>
  glFlush();
}

void resize(int w, int h)
{
  /* ウィンドウ全体をビューポートにする */
  glViewport(0, 0, w, h);

  /* 変換行列の初期化 */
  glLoadIdentity();

  <em>/* 以下削除 */</em>
}

<em>void mouse(int button, int state, int x, int y)
{
  switch (button) {
  case GLUT_LEFT_BUTTON:
    printf(&quot;left&quot;);
    break;
  case GLUT_MIDDLE_BUTTON:
    printf(&quot;middle&quot;);
    break;
  case GLUT_RIGHT_BUTTON:
    printf(&quot;right&quot;);
    break;
  default:
    break;
  }

  printf(&quot; button is &quot;);

  switch (state) {
  case GLUT_UP:
    printf(&quot;up&quot;);
    break;
  case GLUT_DOWN:
    printf(&quot;down&quot;);
    break;
  default:
    break;
  }

  printf(&quot; at (%d, %d)\n&quot;, x, y);
}</em>

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  glutInitWindowPosition(100, 100);
  glutInitWindowSize(320, 240);
  glutInit(&amp;argc, argv);
  glutInitDisplayMode(GLUT_RGBA);
  glutCreateWindow(argv[0]);
  glutDisplayFunc(display);
  glutReshapeFunc(resize);
  <em>glutMouseFunc(mouse);</em>
  init();
  glutMainLoop();
  return 0;
}</pre>

<dl>

<dt><code><a class="label" name="glutmousefunc">glutMouseFunc(void (*func)(int button, int state, int x, int y))</a></code></dt>

<dd>引数 func には,
マウスのボタンが押されたときに実行する関数のポインタを与えます.
この関数の引数 button には押されたボタン
(GLUT_LEFT_BUTTON, GLUT_MIDDLE_BUTTON, GLUT_RIGHT_BUTTON),
state には「押した (GLUT_DOWN)」のか「離した (GLUT_UP)」のか,
x と y にはその位置が渡されます.</dd>

</dl>

<p>プログラムが変更できたら, コンパイルしてプログラムを実行してみてください.
開いたウィンドウの上でマウスのボタンをクリックしてみてください. x と y
に渡される座標は, ウィンドウの<strong>左上隅を原点 (0, 0)</strong>
とした画面上の画素の位置になります.
<strong>デバイス座標系とは上下が反転している</strong>
ので気をつけてください.</p>

<div class="figure"><img src="libglut8.gif" width="256" height="256"
alt="ワールド座標系をマウスの座標系と一致させる方法"></div>

<p>マウスの位置をもとに図形を描く場合は,
マウスの位置からウィンドウ上の座標値を求めなければなりません.
ここではちょっと手を抜いて,
ワールド座標系がこのマウスの座標系に一致するよう
glOrtho() を設定します (上図).
またウィンドウの上下も反転します (prog1.c の下線部).
prog1.c を以下のように変更してください.</p>

<pre class="source">#include &lt;stdio.h&gt;
#include &lt;GL/glut.h&gt;

void display(void)
{
  /* 変更なし */
}

void resize(int w, int h)
{
  /* ウィンドウ全体をビューポートにする */
  glViewport(0, 0, w, h);

  /* 変換行列の初期化 */
  glLoadIdentity();

  <em>/* スクリーン上の座標系をマウスの座標系に一致させる */</em>
  <em>glOrtho(-0.5, (GLdouble)w - 0.5, <span style="text-decoration: underline;">(GLdouble)h - 0.5, -0.5,</span> -1.0, 1.0);</em>
}

void mouse(int button, int state, int x, int y)
{
  <em>static int x0, y0;</em>

  switch (button) {
  case GLUT_LEFT_BUTTON:
<em>    if (state == GLUT_UP) {
      /* ボタンを押した位置から離した位置まで線を引く */
      glColor3d(0.0, 0.0, 0.0);
      glBegin(GL_LINES);
      glVertex2i(x0, y0);
      glVertex2i(x, y);
      glEnd();
      glFlush();
    }
    else {
      /* ボタンを押した位置を覚える */
      x0 = x;
      y0 = y;
    }</em>
    break;
  case GLUT_MIDDLE_BUTTON:
    <em>/* 削除 */</em>
    break;
  case GLUT_RIGHT_BUTTON:
    <em>/* 削除 */</em>
    break;
  default:
    break;
  }

  <em>/* 以下削除 */</em>
}

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  /* 変更なし */
}</pre>

<dl>

<dt><code><a class="label" name="glVertex2i">glVertex2i(GLint, GLint)</a></code></dt>

<dd>この関数は <a href="#glVertex2d">glVertex2d()</a>
と同様に二次元の座標値を設定しますが,
引数の型が GLint 型 (int 型と等価) です.</dd>

</dl>

<p>前のプログラムでは,
ウィンドウのサイズを変えたり
ウインドウが他のウィンドウに隠されたあと再び表示される度に,
ウィンドウの中身が消えてしまいます.
やはり, この場合もちゃんと書き直してやる必要があるわけですが,
そのためにはそれまでに表示した内容を記憶しておかなければなりません.</p>

<p>mouse() が実行されたときに,
配列に現在の位置を記憶しておき,
display() が実行されたときに, それをまとめて描画するようにします.
prog1.c を以下のように変更してください.</p>

<pre class="source">#include &lt;stdio.h&gt;
#include &lt;GL/glut.h&gt;

<em>#define MAXPOINTS 100      /* 記憶する点の数　　 */
GLint point[MAXPOINTS][2]; /* 座標を記憶する配列 */
int pointnum = 0;          /* 記憶した座標の数　 */</em>

void display(void)
{
  <em>int i;</em>

  glClear(GL_COLOR_BUFFER_BIT);

  <em>/* 記録したデータで線を描く */
  if (pointnum &gt; 1) {
    glColor3d(0.0, 0.0, 0.0);
    glBegin(GL_LINES);
    for (i = 0; i &lt; pointnum; ++i) {
      glVertex2iv(point[i]);
    }
    glEnd();
  }</em>

  glFlush();
}

void resize(int w, int h)
{
  /* 変更なし */
}

void mouse(int button, int state, int x, int y)
{
  <em>/* 削除 */</em>

  switch (button) {
  case GLUT_LEFT_BUTTON:
    <em>/* ボタンを操作した位置を記録する */
    point[pointnum][0] = x;
    point[pointnum][1] = y;</em>
    if (state == GLUT_UP) {
      /* ボタンを押した位置から離した位置まで線を引く */
      glColor3d(0.0, 0.0, 0.0);
      glBegin(GL_LINES);
      <em>glVertex2iv(point[pointnum - 1]); /* 一つ前は押した位置　 */</em>
      <em>glVertex2iv(point[pointnum]);     /* 今の位置は離した位置 */</em>
      glEnd();
      glFlush();
    }    
    else {
      <em>/* 削除 */</em>
    }
    <em>if (pointnum &lt; MAXPOINTS - 1) ++pointnum;</em>
    break;
  case GLUT_MIDDLE_BUTTON:
    break;
  case GLUT_RIGHT_BUTTON:
    break;
  default:
    break;
  }
}

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  /* 変更なし */
}</pre>

<dl>

<dt><code>glVertex2iv(const GLint *v)</code></dt>

<dd>この関数は <a href="#glVertex2i">glVertex2i()</a>
と同様に二次元の座標値を設定しますが,
引数 v には 2 個の要素をもつ
GLint 型 (int と等価) の配列を指定します.
v[0] には x 座標値, v[1] には y 座標値を格納します.
この例のように, 複数の点の座標を指定する場合に便利です.</dd>

</dl>

<h3><a class="label" name="7.2">７．２ マウスをドラッグする</a></h3>

<p>マウスのボタンを押しながらマウスを動かす操作を,
<em>ドラッグ</em>と言います.
ドラッグ中はマウスの位置を継続的に取得する必要がありますが,
glutMouseFunc() で指定するハンドラはボタンを押したときにしか実行されないので,
この目的には使用できません.</p>

<p>マウスを動かしたときに実行する関数を指定するには,
glutMotionfunc() または glutPassiveMotionFunc() を使用します.
glutMotionfunc() で指定した関数は,
マウスのボタンを押しながらマウスを動かしたときに実行されます.
glutPassiveMotionFunc() で指定した関数は,
マウスのボタンを押さずにマウスを動かしたときに実行されます.</p>

<p>前のプログラムでは,
マウスの左ボタンを押してから離すまでウィンドウには何も表示されませんでした.
これを, マウスのドラッグ中は線分をマウスに追従して描くようにします.
このような効果を<em>ラバーバンド</em> (輪ゴム) 
と言います. このために glutMotionFunc() を使って,
マウスのドラッグ中にラバーバンドを表示するようにします
(大川 様 ご指摘ありがとうございました).</p>

<pre class="source">#include &lt;stdio.h&gt;
#include &lt;GL/glut.h&gt;

#define MAXPOINTS 100      /* 記憶する点の数　　 */
GLint point[MAXPOINTS][2]; /* 座標を記憶する配列 */
int pointnum = 0;          /* 記憶した座標の数　 */
<em>int rubberband = 0;        /* ラバーバンドの消去 */</em>

void display(void)
{
  /* 変更なし */
}

void resize(int w, int h)
{
  /* 変更なし */
}

void mouse(int button, int state, int x, int y)
{
  switch (button) {
  case GLUT_LEFT_BUTTON:
    /* ボタンを操作した位置を記録する */
    point[pointnum][0] = x;
    point[pointnum][1] = y;
    if (state == GLUT_UP) {
      /* ボタンを押した位置から離した位置まで線を引く */
      glColor3d(0.0, 0.0, 0.0);
      glBegin(GL_LINES);
      glVertex2iv(point[pointnum - 1]); /* 一つ前は押した位置　 */
      glVertex2iv(point[pointnum]);     /* 今の位置は離した位置 */
      glEnd();
      glFlush();

      <em>/* 始点ではラバーバンドを描いていないので消さない */</em>
      <em>rubberband = 0;</em>
    }
    else {
    }
    if (pointnum &lt; MAXPOINTS) ++pointnum;
    break;
  case GLUT_MIDDLE_BUTTON:
    break;
  case GLUT_RIGHT_BUTTON:
    break;
  default:
    break;
  }
}

<em>void motion(int x, int y)
{
  static GLint savepoint[2]; /* 以前のラバーバンドの端点 */

  /* 論理演算機能 ON */
  glEnable(GL_COLOR_LOGIC_OP);
  glLogicOp(GL_INVERT);

  glBegin(GL_LINES);
  if (rubberband) {
    /* 以前のラバーバンドを消す */
    glVertex2iv(point[pointnum - 1]);
    glVertex2iv(savepoint);
  }
  /* 新しいラバーバンドを描く */
  glVertex2iv(point[pointnum - 1]);
  glVertex2i(x, y);
  glEnd();

  glFlush();

  /* 論理演算機能 OFF */
  glLogicOp(GL_COPY);
  glDisable(GL_COLOR_LOGIC_OP);

  /* 今描いたラバーバンドの端点を保存 */
  savepoint[0] = x;
  savepoint[1] = y;
 
  /* 今描いたラバーバンドは次のタイミングで消す */
  rubberband = 1;
}</em>

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  glutInitWindowPosition(100, 100);
  glutInitWindowSize(320, 240);
  glutInit(&amp;argc, argv);
  glutInitDisplayMode(GLUT_RGBA);
  glutCreateWindow(argv[0]);
  glutDisplayFunc(display);
  glutReshapeFunc(resize);
  glutMouseFunc(mouse);
  <em>glutMotionFunc(motion);</em>
  init();
  glutMainLoop();
  return 0;
}</pre>

<dl>

<dt><code>glEnable(GLenum cap)</code></dt>

<dd>引数 cap に指定した機能を使用可能にします.
GL_LOGIC_OP もしくは GL_COLOR_LOGIC_OP
は, 図形の描画の際にウィンドウに既に描かれている内容と,
これから描こうとする内容の間で論理演算を行うことができるようにします.
</dd>

<dt><code>glDisable(GLenum cap)</code></dt>

<dd>引数 cap に指定した機能を使用不可にします.</dd>

<dt><code>glLogicOp(GLenum opcode)</code></dt>

<dd>引数 opcode にはウィンドウに描かれている内容と,
これから描こうとする内容との間で行う論理演算のタイプを指定します.
GL_COPY はこれから描こうとする内容をそのままウィンドウ内に描きます.
GL_INVERT はウィンドウに描かれている内容の,
これから描こうとする図形の領域を反転します.
詳しくは man glLogicOp を参照してください.</dd>

<dt><code><a class="label" name="glutmotionfunc">glutMotionFunc(void (*func)(int x, int y))</a></code></dt>

<dd>引数 func には,
マウスのいずれかのボタンを押しながらマウスを動かしたときに
実行する関数のポインタを与えます.
この関数の引数 x と y には, 現在のマウスの位置が渡されます.
この設定を解除するには, 引数に 0 (ヌルポインタ) を指定します
(stdio.h 等の中で定義されている記号定数 NULL を使用しても良い).</dd>

</dl>

<p>ラバーバンドを実現する場合,
マウスを動かしたときに直前に描いたラバーバンドを消す必要があります.
また, ラバーバンドを描いたことによって
ウィンドウに既に描かれていた内容が壊されてしまうので,
その部分をもう一度描き直す必要があります.
しかし, そのために画面全体を書き換えるのは,
ちょっともったいない気がします.</p>

<p>そこでラバーバンドを描く際には,
線を背景とは異なる色で描く代わりに,
描こうとする線上の画素の色を反転するようにします.
こうすればもう一度同じ線上の画素の色を反転することで,
そこに描かれていた以前の線が消えてウィンドウに描かれた図形が元に戻ります.
このために glLogicOp() を使用します.
glLogicOp() で指定した論理演算は,
glEnable(GL_LOGIC_OP)＜白黒の場合＞あるいは
glEnable(GL_COLOR_LOGIC_OP)＜カラーの場合＞で有効になります
(陳 先生 ご指摘ありがとうございました).</p>

<p>ただし, マウスのボタンを押した直後はまだラバーバンドは描かれていませんから,
そのときだけラバーバンドの消去は行わないようにしなければなりません.
このため rubberband
なんていう変数を使ったちょっと泥臭いプログラムになっていますが,
我慢してください (もっとエレガントな方法もありますけど&#133;).</p>

<p>glutMotionFunc(), glutPassiveMotionFunc() で指定した関数は,
マウスの移動にともなって頻繁に実行されるので,
この関数の中で時間のかかる処理を行うと,
マウスの応答が悪くなってしまいます.
これを避ける方法は<a href="#9">９節</a>以降で解説します.</p>

<h3><a class="label" name="7.3">７．３ キーボードから読み込む</a></h3>

<p>OpenGL のアプリケーションプログラムが開いたウィンドウには,
ターミナルウィンドウのようにキーボード入力を行うことができません.
そのかわりマウスのボタン同様,
キーをタイプするごとに実行する関数を指定できます.
それには glutKeyboardFunc() を使います.</p>

<p>これまで作ったプログラムは,
プログラムを終了する方法を組み込んでいませんでした.
そこで q のキーや ESC キーをタイプしたときに exit()
を呼び出して, プログラムが終了するようにします.
また exit() を使うために stdlib.h も include します.
prog1.c を以下のように変更してください.</p>

<pre class="source">#include &lt;stdio.h&gt;
<em>#include &lt;stdlib.h&gt;</em>
#include &lt;GL/glut.h&gt;

#define MAXPOINTS 100      /* 記憶する点の数　　 */
GLint point[MAXPOINTS][2]; /* 座標を記憶する配列 */
int pointnum = 0;          /* 記憶した座標の数　 */
int rubberband = 0;        /* ラバーバンドの消去 */

void display(void)
{
  /* 変更なし */
}

void resize(int w, int h)
{
  /* 変更なし */
}

void mouse(int button, int state, int x, int y)
{
  /* 変更なし */
}

void motion(int x, int y)
{
  /* 変更なし */
}

<em>void keyboard(unsigned char key, int x, int y)
{
  switch (key) {
  case 'q':
  case 'Q':
  case '\033':  /* '\033' は ESC の ASCII コード */
    exit(0);
  default:
    break;
  }
}</em>

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  glutInitWindowPosition(100, 100);
  glutInitWindowSize(320, 240);
  glutInit(&amp;argc, argv);
  glutInitDisplayMode(GLUT_RGBA);
  glutCreateWindow(argv[0]);
  glutDisplayFunc(display);
  glutReshapeFunc(resize);
  glutMouseFunc(mouse);
  glutMotionFunc(motion);
  <em>glutKeyboardFunc(keyboard);</em>
  init();
  glutMainLoop();
  return 0;
}</pre>

<dl>

<dt><code>glutKeyboardFunc(void (*func)(unsigned char key, int x, int y))</code></dt>

<dd>引数 func には,
キーがタイプされたときに実行する関数のポインタを与えます.
この関数の引数 key にはタイプされたキーの ASCII コードが渡されます.
また x と y にはキーがタイプされたときのマウスの位置が渡されます.</dd>

</dl>

<p>ファンクションキーのような文字キー以外のタイプを検出するときは
glutSpecialFunc(), Shift や Ctrl
のようなモディファイア (修飾) キーを検出するには
glutGetModifiers() を使います.
使い方はいずれも man コマンドで調べてください.</p>

<h2><a class="label" name="8">８．三次元図形を描く</a></h2>

<h3><a class="label" name="8.1">８．１ 二次元と三次元</a></h3>

<p>これまでは二次元の図形の表示を行ってきましたが,
OpenGL の内部では実際には三次元の処理を行っています.
すなわち画面表示に対して垂直に Z 軸が伸びており,
これまではその三次元空間の xy 平面への平行投影像を表示していました.</p>

<div class="figure"><img src="axis.gif" width="184" height="254" alt="スクリーンの座標系"></div>

<p>試しに<a href="#5.4">５．４節</a>で作成したプログラム (prog2.c) において,
図形を y 軸中心に 25 度回転してみましょう.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

void display(void)
{
  glClear(GL_COLOR_BUFFER_BIT);
  <em>glRotated(25.0, 0.0, 1.0, 0.0);</em>
  glBegin(GL_POLYGON);
  glColor3d(1.0, 0.0, 0.0); /* 赤 */
  glVertex2d(-0.9, -0.9);
  glColor3d(0.0, 1.0, 0.0); /* 緑 */
  glVertex2d(0.9, -0.9);
  glColor3d(0.0, 0.0, 1.0); /* 青 */
  glVertex2d(0.9, 0.9);
  glColor3d(1.0, 1.0, 0.0); /* 黄 */
  glVertex2d(-0.9, 0.9);
  glEnd();
  glFlush();
}

void init(void)
{
  glClearColor(1.0, 1.0, 1.0, 1.0);
}

int main(int argc, char *argv[])
{
  glutInit(&amp;argc, argv);
  glutInitDisplayMode(GLUT_RGBA);
  glutCreateWindow(argv[0]);
  glutDisplayFunc(display);
  init();
  glutMainLoop();
  return 0;
}</pre>

<dl>

<dt><a class="label" name="glRotated"><code>glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)</code></a></dt>

<dd>変換行列に回転の行列を乗じます.
引数はいずれも GLdouble 型 (double と等価) で, 一つ目の引数 angle は回転角,
残りの三つの引数 x, y, z は回転軸の方向ベクトルです.
引数が float 型なら glRotatef() を使います.
原点を通らない軸で回転させたい場合は,
<a href="#glTranslated">glTranslated()</a>
を使って一旦軸が原点を通るように図形を移動し,
回転後に元の位置に戻します.</dd>

</dl>

<p>コンパイルしたプログラムを実行して, 描かれる図形を見てください.
Y 軸中心に回転しているため,
以前に比べて少し縦長になっていると思います.</p>

<p>このウィンドウを最小化したり他のウィンドウを重ねたりして,
再描画をさせてみましょう. 再描画する度に図形の形が変わると思います.
これは変換行列に glRotated() による回転の行列が積算されるからです.
これを防ぐには描画の度に変換マトリクスを glLoadIdentity() で初期化するか,
後で述べる glPushMatrix() / glPopMatrix() を使って変換行列を保存します.</p>

<h3><a class="label" name="8.2">８．２ 線画を表示する</a></h3>

<p>それでは, こんどは以下のような三次元の立方体を線画で描いてみましょう.
glut には glutWireCube() など,
いくつか基本的な立体を描く関数があるのですが,
ここでは自分で形状を定義してみたいと思います.</p>

<div class="figure"><img src="libglut5.gif" width="400" height="337"
alt="立方体の構造"></div>

<p>この図形は 8 個の点を 12 本の線分で結びます.
点の位置 (幾何情報) と線分 (位相情報) を別々にデータにします.</p>

<pre class="source">GLdouble vertex[][3] = {
  { 0.0, 0.0, 0.0 }, /* A */
  { 1.0, 0.0, 0.0 }, /* B */
  { 1.0, 1.0, 0.0 }, /* C */
  { 0.0, 1.0, 0.0 }, /* D */
  { 0.0, 0.0, 1.0 }, /* E */
  { 1.0, 0.0, 1.0 }, /* F */
  { 1.0, 1.0, 1.0 }, /* G */
  { 0.0, 1.0, 1.0 }  /* H */
};

int edge[][2] = {
  { 0, 1 }, /* ア (A-B) */
  { 1, 2 }, /* イ (B-C) */
  { 2, 3 }, /* ウ (C-D) */
  { 3, 0 }, /* エ (D-A) */
  { 4, 5 }, /* オ (E-F) */
  { 5, 6 }, /* カ (F-G) */
  { 6, 7 }, /* キ (G-H) */
  { 7, 4 }, /* ク (H-E) */
  { 0, 4 }, /* ケ (A-E) */
  { 1, 5 }, /* コ (B-F) */
  { 2, 6 }, /* サ (C-G) */
  { 3, 7 }  /* シ (D-H) */
};</pre>

<p>この場合, 例えば &quot;点 C&quot; (1,1,0) と&quot;点 D&quot; (0,1,0)
を結ぶ線分 &quot;ウ&quot; は, 以下のようにして描画できます.
glVertex3dv() は,
引数に三つの要素を持つ
GLdouble 型 (double と等価) の配列のポインタを与えて,
頂点を指定します.</p>

<pre class="source">glBegin(GL_LINES);
glVertex3dv(vertex[edge[2][0]]); /* 線分 &quot;ウ&quot; の一つ目の端点 &quot;C&quot; */
glVertex3dv(vertex[edge[2][1]]); /* 線分 &quot;ウ&quot; の二つ目の端点 &quot;D&quot; */
glEnd();</pre>

<p>従って立方体全部を描くプログラムは以下のようになります.
なお, 立方体がウィンドウからはみ出ないように,
glOrtho() で表示する座標系を (-2,-2)〜(2,2) にしています.
prog2.c を以下のように変更してください.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

<em>GLdouble vertex[][3] = {
  { 0.0, 0.0, 0.0 },
  { 1.0, 0.0, 0.0 },
  { 1.0, 1.0, 0.0 },
  { 0.0, 1.0, 0.0 },
  { 0.0, 0.0, 1.0 },
  { 1.0, 0.0, 1.0 },
  { 1.0, 1.0, 1.0 },
  { 0.0, 1.0, 1.0 }
};

int edge[][2] = {
  { 0, 1 },
  { 1, 2 },
  { 2, 3 },
  { 3, 0 },
  { 4, 5 },
  { 5, 6 },
  { 6, 7 },
  { 7, 4 },
  { 0, 4 },
  { 1, 5 },
  { 2, 6 },
  { 3, 7 }
};</em>

void display(void)
{
<em>  int i;</em>

  glClear(GL_COLOR_BUFFER_BIT);

<em>  /* 図形の描画 */
  glColor3d(0.0, 0.0, 0.0);
  glBegin(GL_LINES);
  for (i = 0; i &lt; 12; ++i) {
    glVertex3dv(vertex[edge[i][0]]);
    glVertex3dv(vertex[edge[i][1]]);
  }
  glEnd();</em>

  glFlush();
}

<em>void resize(int w, int h)
{
  glViewport(0, 0, w, h);

  glLoadIdentity();
  glOrtho(-2.0, 2.0, -2.0, 2.0, -2.0, 2.0);
}</em>

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  glutInit(&amp;argc, argv);
  glutInitDisplayMode(GLUT_RGBA);
  glutCreateWindow(argv[0]);
  glutDisplayFunc(display);
  <em>glutReshapeFunc(resize);</em>
  init();
  glutMainLoop();
  return 0;
}</pre>

<dl>

<dt><code>glVertex3dv(const GLdouble *v)</code></dt>

<dd>glVertex3dv() は三次元の座標値を指定するのに使います.
引数 v は 3 個の要素を持つ GLdouble 型 (double と等価) 配列を指定します.
v[0] には x 座標値, v[1] には y 座標値, v[2] には z 座標値を格納します.</dd>

</dl>

<h3><a class="label" name="8.3">８．３ 透視投影する</a></h3>

<p>前のプログラムでは, 立方体が画面に平行投影されるため,
正方形しか描かないと思います.
そこで現実のカメラのように透視投影をしてみます.
これには glOrtho() の代わりに gluPerspective() を使います.</p>

<p>gluPerspective() は座標軸の代わりに,
カメラの画角やスクリーンのアスペクト比 (縦横比) を用いて表示領域を指定します.
また glOrtho() 同様, 前方面や後方面の位置の指定も行います.</p>

<p>視点の位置の初期値は原点なので,
このままでは立方体が視点に重なってしまいます.
そこで glTranslated() を使って立方体の位置を少し奥にずらしておきます.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

GLdouble vertex[][3] = {
  /* 変更なし */
};

int edge[][2] = {
  /* 変更なし */
};

void display(void)
{
  /* 変更なし */
}

void resize(int w, int h)
{
  glViewport(0, 0, w, h);

  glLoadIdentity();
  <em>gluPerspective(30.0, (double)w / (double)h, 1.0, 100.0);</em>
  <em>glTranslated(0.0, 0.0, -5.0);</em>
}

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  /* 変更なし */
}</pre>

<dl>

<dt><code><a class="label" name="gluPerspective">gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar)</a></code></dt>

<dd>変換行列に透視変換の行列を乗じます.
最初の引数 fovy はカメラの画角であり, 度で表します.
これが大きいほどワイドレンズ (透視が強くなり, 絵が小さくなります) になり,
小さいほど望遠レンズになります.
二つ目の引数 aspect は画面のアスペクト比 (縦横比) であり,
1 であればビューポートに表示される図形の
x 方向と y 方向のスケールが等しくなります.
三つ目の引数 zNear と四つ目の引数 zFar は表示を行う奥行き方向の範囲で,
zNear は手前 (前方面), zFar は後方 (後方面) の位置を示します.
この間にある図形が描画されます.
<div class="figure"><img src="perspective.gif" width="513" height="161"
alt="透視変換の視野"></div>
</dd>

<dt><code><a class="label" name="glTranslated">glTranslated(GLdouble x, GLdouble y, GLdouble z)</a></code></dt>

<dd>変換行列に平行移動の行列を乗じます.
引数はいずれも GLdouble 型 (double と等価) で,
三つの引数 x, y, z には現在の位置からの相対的な移動量を指定します.
引数が float 型なら glTranslatef() を使います.</dd>

</dl>

<p>ウィンドウをリサイズしたときに表示図形がゆがまないようにするためには,
gluPerspective() で設定するアスペクト比 aspect を,
<a href="#glViewport">glViewport()</a>
で指定したビューポートの縦横比 (w/h)
と一致させます.</p>

<p>上のプログラムのように,
リサイズ後のウィンドウのサイズをそのままビューポートに設定している場合,
仮に aspect が定数であれば,
ウィンドウのリサイズに伴って表示図形が伸縮するようになります. したがって,
ウィンドウをリサイズしても表示図形の縦横比が変わらないようにするために,
ここでは aspect をビューポートの縦横比に設定しています.</p>

<h3><a class="label" name="8.4">８．４ 視点の位置を変更する</a></h3>

<p>前のプログラムのように,
視点の位置を移動するには, 図形の方を
glTranslated() や glRotated() を用いて逆方向に移動することで実現できます.
しかし, 視点を任意の位置に指定したいときには gluLookAt() を使うと便利です.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

GLdouble vertex[][3] = {
  /* 変更なし */
};

int edge[][2] = {
  /* 変更なし */
};

void display(void)
{
  /* 変更なし */
}

void resize(int w, int h)
{
  glViewport(0, 0, w, h);

  glLoadIdentity();
  gluPerspective(30.0, (double)w / (double)h, 1.0, 100.0);
  <em>gluLookAt(3.0, 4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);</em>
}

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  /* 変更なし */
}</pre>

<dl>

<dt><code>void gluLookAt(GLdouble ex, GLdouble ey, GLdouble ez, GLdouble cx, GLdouble cy, GLdouble cz, GLdouble ux, GLdouble uy, GLdouble uz)</code></dt>

<dd>この最初の三つの引数 ex, ey, ez は視点の位置,
次の三つの引数 cx, cy, cz は目標の位置,
最後の三つの引数 ux, uy, uz は,
ウィンドウに表示される画像の「上」の方向を示すベクトルです.</dd>

</dl>

<p>この例では (3,4,5) の位置から原点 (0,0,0) を眺めますから,
立方体の A (0,0,0) の頂点がウィンドウの中心に来ると思います.</p>

<p>なお, gluPerspective(), gluLookAt() 等,
glu*() で始まる関数は GL Utility ライブラリ (-lGLU) の関数です.</p>

<h2><a class="label" name="9">９．アニメーション</a></h2>

<h3><a class="label" name="9.1">９．１ 図形を動かす</a></h3>

<p>ここまでできたら, 今度はこの立方体を回してみましょう.
それにはちょっと工夫が必要です. アニメーションを行うには,
頻繁に画面の書き換えを行う必要があります.
しかし glutMailLoop() は無限ループであり,
glutDisplayFunc() で指定された関数は,
ウィンドウを再描画するイベントが発生したときにしか呼び出されません.</p>

<p>したがってアニメーションを実現するには,
このウィンドウの再描画イベントを連続的に発生させる必要があります.
プログラム中でウィンドウの再描画イベントを発生させるには,
glutPostRedisplay() 関数を用います.
これをプログラムが「暇なとき」に繰り返し呼び出すことで,
アニメーションが実現できます.
プログラムが暇になったときに実行する関数は,
glutIdleFunc() で指定します.</p>

<p><a class="label" name="viewpipe">一つ注意しなければいけないことがあります.</a>
繰り返し描画を行うには,
描画の度に座標変換の行列を設定する必要があります.</p>

<p>ところで座標変換のプロセスは, </p>

<ol>
<li>図形の空間中での位置を決める「モデリング変換」</li>
<li>その空間を視点から見た空間に直す「ビューイング (視野) 変換」</li>
<li>その空間をコンピュータ内の空間にあるスクリーンに投影する「透視変換」</li>
<li>スクリーン上の図形をディスプレイ上の表示領域に切り出す「ビューポート変換」</li>
</ol>

<p>という四つのステップで行われます.
今行おうとしている図形を回すという変換は,
「モデリング変換」に相当します.</p>

<p>これまではこれらを区別 せずに取り扱ってきました.
すなわち, これらの投影を行う行列式を掛け合わせることで,
単一の行列式として取り扱ってきたのです.</p>

<p>しかし図形だけを動かす場合は,
モデリング変換の行列だけを変更すればいいことになります.
また, 後で述べる<a href="#11">陰影付け</a>は,
透視変換を行う前の座標系で計算する必要があります.</p>

<p>そこで OpenGL では,
「モデリング変換−ビューイング変換」の変換行列 (モデルビュー変換行列) と,
「透視変換」の変換行列を独立して取り扱う手段が提供されています.
モデルビュー変換行列を設定する場合は
 glMatrixMode(GL_MODELVIEW),
透視変換行列を設定する場合は glMatrixMode(GL_PROJECTION) を実行します.</p>

<p>カメラの画角などのパラメータを変更しなければ,
透視変換行列を設定しなければならないのはウィンドウを開いたときだけなので,
これは resize() で設定すればよいでしょう.
あとは全てモデリング−ビューイング変換行列に対する操作なので,
直後に glMatrixMode(GL_MODELVIEW) を実行します.</p>

<p>カメラ (視点) の位置を動かすアニメーションを行う場合は,
描画のたびに gluLookAt() によるカメラの位置や方向の設定
(ビューイング変換行列の設定) 
を行う必要があります.
同様に物体が移動したり回転したりするアニメーションを行う場合も,
描画のたびに物体の位置や回転角の設定 (モデリング変換行列の設定) を
行う必要があります.
したがって, これらは display() の中で設定します.</p>

<p>マウスの左ボタンをクリックしている間,
立方体が回転するようにします.
ついでに右ボタンをクリックすると立方体が 1 ステップだけ回転し
(<a href="http://www1.bbiq.jp/sekiya_z/cg/">関谷 先生</a>
ご指摘ありがとうございました),
'q', 'Q', または ESC キーでプログラムが終了するようにします.
prog2.c を以下のように変更してください.</p>

<pre class="source"><em>#include &lt;stdlib.h&gt;</em>
#include &lt;GL/glut.h&gt;

GLdouble vertex[][3] = {
  /* 変更なし */
};

int edge[][2] = {
  /* 変更なし */
};

<em>void idle(void)
{
  glutPostRedisplay();
}</em>

void display(void)
{
  int i;
  <em>static int r = 0; /* 回転角 */</em>

  glClear(GL_COLOR_BUFFER_BIT);

  <em>glLoadIdentity();</em>

  <em>/* 視点位置と視線方向 */</em>
  <em>gluLookAt(3.0, 4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);</em>

  <em>/* 図形の回転 */</em>
  <em>glRotated((double)r, 0.0, 1.0, 0.0);</em>

  /* 図形の描画 */
  glColor3d(0.0, 0.0, 0.0);
  glBegin(GL_LINES);
  for (i = 0; i &lt; 12; ++i) {
    glVertex3dv(vertex[edge[i][0]]);
    glVertex3dv(vertex[edge[i][1]]);
  }
  glEnd();

  glFlush();

  <em>/* 一周回ったら回転角を 0 に戻す */</em>
  <em>if (++r &gt;= 360) r = 0;</em>
}

void resize(int w, int h)
{
  glViewport(0, 0, w, h);

  <em>/* 透視変換行列の設定 */</em>
  <em>glMatrixMode(GL_PROJECTION);</em>
  glLoadIdentity();
  gluPerspective(30.0, (double)w / (double)h, 1.0, 100.0);

  <em>/* モデルビュー変換行列の設定 */</em>
  <em>glMatrixMode(GL_MODELVIEW);</em>
}

<em>void mouse(int button, int state, int x, int y)
{
  switch (button) {
  case GLUT_LEFT_BUTTON:
    if (state == GLUT_DOWN) {
      /* アニメーション開始 */
      glutIdleFunc(idle);
    }
    else {
      /* アニメーション停止 */
      glutIdleFunc(0);
    }
    break;
  case GLUT_RIGHT_BUTTON:
    if (state == GLUT_DOWN) {
      /* コマ送り (<em>1</em>ステップだけ進める) */
        glutPostRedisplay();
    }
    break;
  default:
    break;
  }
}</em>
  
<em>void keyboard(unsigned char key, int x, int y)
{
  switch (key) {
  case 'q':
  case 'Q':
  case '\033':  /* '\033' は ESC の ASCII コード */
    exit(0);
  default:
    break;
  }
}</em>

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  glutInit(&amp;argc, argv);
  glutInitDisplayMode(GLUT_RGBA);
  glutCreateWindow(argv[0]);
  glutDisplayFunc(display);
  glutReshapeFunc(resize);
  <em>glutMouseFunc(mouse);</em>
  <em>glutKeyboardFunc(keyboard);</em>
  init();
  glutMainLoop();
  return 0;
}</pre>

<dl>

<dt><code>void glutPostRedisplay(void)</code></dt>

<dd>再描画イベントを発生させます.
このイベントの発生が発生すると,
glutDisplayFunc()
で指定されている描画関数が実行されます.
なお, 再描画が開始されるまでの間にこのイベントが複数回発生しても,
この描画関数は一度だけ実行されます.</dd>

<dt><code>void glutIdleFunc(void (*func)(void))</code></dt>

<dd>引数 func には,
このプログラムが暇な (何もすることがない)
ときに実行する関数のポインタを指定します.
引数の関数はプログラムが「暇になる」たびに繰り返し実行されます.
この関数を指定すると,
プログラムが止まっているように見えてもコンピュータの負荷は増大します.
したがって glutIdleFunc() による関数の指定は必要になった時点で行い,
不要になれば glutIdleFunc() の引数に 0 または NULL
を指定して関数の指定を解除してやる必要があります.</dd>

<dt><code>void glMatrixMode(GLenum mode)</code></dt>

<dd>設定する変換行列を指定します.
引数 mode が GL_MODELVIEW ならモデルビュー変換行列,
GL_PROJECTION なら透視変換行列を指定します.</dd>

</dl>

<h3><a class="label" name="9.2">９．２ ダブルバッファリング</a></h3>

<p>前のプログラムでは毎回画面を全部描き換えているため,
表示がちらついてしまいます.
これを防ぐためには, ダブルバッファリングという方法を用います.
これは画面を二つに分け,
一方を表示している間に (見えないところで) もう一方に図形を描き,
それが完了したらこの二つの画面を入れ換える方法です.</p>

<p>GLUT でダブルバッファリングを使うには,
glutInitDisplayMode() に GLUT_DOUBLE の指定を追加します.
また, 図形の描画後に実行している glFlush() を <em>glutSwapBuffers()</em>
に<strong>置き換えて</strong>, ここで二つの画面の入れ換えを行います.</p>

<p>それでは, prog2.c でダブルバッファリングを行うようにしてみましょう.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

GLdouble vertex[][3] = {
  /* 変更なし */
};

int edge[][2] = {
  /* 変更なし */
};

void idle(void)
{
  /* 変更なし */
}

void display(void)
{
  int i;
  static int r = 0; /* 回転角 */

  glClear(GL_COLOR_BUFFER_BIT);

  glLoadIdentity();

  /* 視点位置と視線方向 */
  gluLookAt(3.0, 4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);

  /* 図形の回転 */
  glRotated((double)r, 0.0, 1.0, 0.0);

  /* 図形の描画 */
  glColor3d(0.0, 0.0, 0.0);
  glBegin(GL_LINES);
  for (i = 0; i &lt; 12; ++i) {
    glVertex3dv(vertex[edge[i][0]]);
    glVertex3dv(vertex[edge[i][1]]);
  }
  glEnd();

  <em>glutSwapBuffers();</em>

  /* 一周回ったら回転角を 0 に戻す */
  if (++r &gt;= 360) r = 0;
}

void resize(int w, int h)
{
  /* 変更なし */
}

void mouse(int button, int state, int x, int y)
{
  /* 変更なし */
}
  
void keyboard(unsigned char key, int x, int y)
{
  /* 変更なし */
}

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  glutInit(&amp;argc, argv);
  glutInitDisplayMode(GLUT_RGBA <em>| GLUT_DOUBLE</em>);
  glutCreateWindow(argv[0]);
  glutDisplayFunc(display);
  glutReshapeFunc(resize);
  glutMouseFunc(mouse);
  glutKeyboardFunc(keyboard);
  init();
  glutMainLoop();
  return 0;
}</pre>

<dl>

<dt><code>int glutSwapBuffers(void)</code></dt>

<dd>ダブルバッファリングの二つのバッファを交換します.
glFlush() は自動的に実行されます.
このプログラムでこれを使うとずいぶん遅くなるように見えますが,
これはディスプレイのバッファの交換の時のちらつきを防ぐために,
ディスプレイの表示タイミング (帰線消去期間) を待っているためです.
ディスプレイのリフレッシュレートが 60Hz であれば,
バッファの交換は 1/60 秒ごとに行われます.
このプログラムは一周で 360 回再表示を行いますから,
この場合一周するのに最短でも 6 秒かかることになります.</dd>

</dl>

<h2><a class="label" name="10">１０．隠面消去処理</a></h2>

<h3><a class="label" name="10.1">１０．１ 多面体をぬりつぶす</a></h3>

<p>それでは, 次に立方体の面を塗りつぶしてみましょう.
面のデータは, 稜線とは別に以下のように用意します.</p>

<pre class="source">int face[][4] = {
  { 0, 1, 2, 3 }, /* A-B-C-D を結ぶ面 */
  { 1, 5, 6, 2 }, /* B-F-G-C を結ぶ面 */
  { 5, 4, 7, 6 }, /* F-E-H-G を結ぶ面 */
  { 4, 0, 3, 7 }, /* E-A-D-H を結ぶ面 */
  { 4, 5, 1, 0 }, /* E-F-B-A を結ぶ面 */
  { 3, 2, 6, 7 }  /* D-C-G-H を結ぶ面 */
};</pre>

<p>このデータを使って, 線を引く代わりに 6 枚の四角形を描きます.
prog2.c を以下のように変更してください.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

GLdouble vertex[][3] = {
  /* 変更なし */
};

<em>int face[][4] = {
  { 0, 1, 2, 3 },
  { 1, 5, 6, 2 },
  { 5, 4, 7, 6 },
  { 4, 0, 3, 7 },
  { 4, 5, 1, 0 },
  { 3, 2, 6, 7 }
};</em>

void idle(void)
{
  /* 変更なし */
}

void display(void)
{
  int i;
  <em>int j;</em>
  static int r = 0; /* 回転角 */

  glClear(GL_COLOR_BUFFER_BIT);

  glLoadIdentity();

  /* 視点位置と視線方向 */
  gluLookAt(3.0, 4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);

  /* 図形の回転 */
  glRotated((double)r, 0.0, 1.0, 0.0);

  /* 図形の描画 */
  glColor3d(0.0, 0.0, 0.0);
  <em>glBegin(GL_QUADS);</em>
  <em>for (j = 0; j &lt; 6; ++j) {</em>
    <em>for (i = 0; i &lt; 4; ++i) {</em>
      <em>glVertex3dv(vertex[face[j][i]]);</em>
    <em>}</em>
  <em>}</em>
  <em>glEnd();</em>

  glutSwapBuffers();

  /* 一周回ったら回転角を 0 に戻す */
  if (++r &gt;= 360) r = 0;
}

void resize(int w, int h)
{
  /* 変更なし */
}

void mouse(int button, int state, int x, int y)
{
  /* 変更なし */
}
  
void keyboard(unsigned char key, int x, int y)
{
  /* 変更なし */
}

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  /* 変更なし */
}</pre>

<p>でもこれだと真っ黒で何もわからないので,
面ごとに色を変えてみましょう.
色のデータは以下のように作ってみます.</p>

<pre class="source">GLdouble color[][3] = {
  { 1.0, 0.0, 0.0 }, /* 赤 */
  { 0.0, 1.0, 0.0 }, /* 緑 */
  { 0.0, 0.0, 1.0 }, /* 青 */
  { 1.0, 1.0, 0.0 }, /* 黄 */
  { 1.0, 0.0, 1.0 }, /* マゼンタ */
  { 0.0, 1.0, 1.0 }  /* シアン 　*/
};</pre>

<p>一つの面を描く度に, この色を設定してやります.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

GLdouble vertex[][3] = {
  /* 変更なし */
};

int face[][4] = {
  /* 変更なし */
};

<em>GLdouble color[][3] = {
  { 1.0, 0.0, 0.0 },
  { 0.0, 1.0, 0.0 },
  { 0.0, 0.0, 1.0 },
  { 1.0, 1.0, 0.0 },
  { 1.0, 0.0, 1.0 },
  { 0.0, 1.0, 1.0 }
};</em>

void idle(void)
{
  /* 変更なし */
}

void display(void)
{
  int i;
  int j;
  static int r = 0; /* 回転角 */

  glClear(GL_COLOR_BUFFER_BIT);

  glLoadIdentity();

  /* 視点位置と視線方向 */
  gluLookAt(3.0, 4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);

  /* 図形の回転 */
  glRotated((double)r, 0.0, 1.0, 0.0);

  /* 図形の描画 */
  glBegin(GL_QUADS);
  for (j = 0; j &lt; 6; ++j) {
    <em>glColor3dv(color[j]);</em>
    for (i = 0; i &lt; 4; ++i) {
      glVertex3dv(vertex[face[j][i]]);
    }
  }
  glEnd();

  glutSwapBuffers();

  /* 一周回ったら回転角を 0 に戻す */
  if (++r &gt;= 360) r = 0;
}

void resize(int w, int h)
{
  /* 変更なし */
}

void mouse(int button, int state, int x, int y)
{
  /* 変更なし */
}
  
void keyboard(unsigned char key, int x, int y)
{
  /* 変更なし */
}

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  /* 変更なし */
}</pre>

<dl>

<dt><code><a class="label" name="glColor3dv">void glColor3dv(const GLdouble *v)</a></code></dt>

<dd>glColor3dv() は <a href="#glColor3d">glColor3d()</a>
と同様にこれから描画するものの色を指定します.
引数 v は三つの要素を持った GLdouble 型 (double と等価) の配列で,
v[0] には赤 (R), v[1] には緑 (G), v[2] には青 (B) の強さを,
0〜1 の範囲で指定します.</dd>

</dl>

<p>でもこれだとなんか変な表示になるかもしれません.
前のプログラムではデータの順番で面を描いていますから,
先に描いたものが後に描いたもので塗りつぶされてしまいます.
ちゃんとした立体を描くには<em>隠面消去処理</em>を行う必要があります.</p>

<h3><a class="label" name="10.2">１０．２ デプスバッファを使用する</a></h3>

<p>隠面消去処理を行なうには
glutInitDisplayMode() で GLUT_DEPTH を指定しておき,
glEnable(GL_DEPTH_TEST) を実行します.
こうすると, 描画のときにデプスバッファを使うようになります.
このため, 画面 (フレームバッファ, カラーバッファ)
を消去するときにデプスバッファも一緒に消去しておきます.
それには glClear() の引数に GL_DEPTH_BUFFER_BIT を追加します.</p>

<p>デプスバッファを使うと, 使わないときより処理速度が低下します.
そこで, 必要なときだけデプスバッファを使うようにします.
デプスバッファを使う処理の前で glEnable(GL_DEPTH_TEST) を実行し,
使い終わったら glDisable(GL_DEPTH_TEST) を実行します.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

GLdouble vertex[][3] = {
  /* 変更なし */
};

int face[][4] = {
  /* 変更なし */
};

GLdouble color[][3] = {
  /* 変更なし */
};

void idle(void)
{
  /* 変更なし */
}

void display(void)
{
  int i;
  int j;
  static int r = 0; /* 回転角 */

  glClear(GL_COLOR_BUFFER_BIT <em>| GL_DEPTH_BUFFER_BIT</em>);

  glLoadIdentity();

  /* 視点位置と視線方向 */
  gluLookAt(3.0, 4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);

  /* 図形の回転 */
  glRotated((double)r, 0.0, 1.0, 0.0);

  /* 図形の描画 */
  glBegin(GL_QUADS);
  for (j = 0; j &lt; 6; ++j) {
    glColor3dv(color[j]);
    for (i = 0; i &lt; 4; ++i) {
      glVertex3dv(vertex[face[j][i]]);
    }
  }
  glEnd();

  glutSwapBuffers();

  /* 一周回ったら回転角を 0 に戻す */
  if (++r &gt;= 360) r = 0;
}

void resize(int w, int h)
{
  /* 変更なし */
}

void mouse(int button, int state, int x, int y)
{
  /* 変更なし */
}
  
void keyboard(unsigned char key, int x, int y)
{
  /* 変更なし */
}

void init(void)
{
  glClearColor(1.0, 1.0, 1.0, 1.0);

  <em>glEnable(GL_DEPTH_TEST);</em>
}

int main(int argc, char *argv[])
{
  glutInit(&amp;argc, argv);
  glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE <em>| GLUT_DEPTH</em>);
  glutCreateWindow(argv[0]);
  glutDisplayFunc(display);
  glutReshapeFunc(resize);
  glutMouseFunc(mouse);
  glutKeyboardFunc(keyboard);
  init();
  glutMainLoop();
  return 0;
}</pre>

<p><a class="label" name="depthtest"></a>上のプログラムでは常にデプスバッファを使うので,
init() の中で glEnable(GL_DEPTH_TEST)
を一度だけ実行し, glDisable(GL_DEPTH_TEST)
の実行を省略しています.</p>

<h3><a class="label" name="10.3">１０．３ カリング</a></h3>

<p>立方体のように閉じた立体の場合, 裏側にある面,
すなわち視点に対して背を向けている面は見ることはできません.
そういう面をあらかじめ取り除いておくことで,
隠面消去処理の効率を上げることができます.</p>

<p>視点に対して背を向けている面を表示しないようにするには
glCullFace(GL_BACK),
表を向いている面を表示しないようにするには
glCullFace(GL_FRONT),
両方とも表示しないようにするには
glCullFace(GL_FRONT_AND_BACK)
を実行します. ただし, この状態でも点や線などは描画されます.</p>

<p>また, glCullFace() を有効にするには glEnable(GL_CULL_FACE),
無効にするには glDisable(GL_CULL_FACE) を実行します.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

GLdouble vertex[][3] = {
  /* 変更なし */
};

int face[][4] = {
  /* 変更なし */
};

GLdouble color[][3] = {
  /* 変更なし */
};

void idle(void)
{
  /* 変更なし */
}

void display(void)
{
  int i;
  int j;
  static int r = 0; /* 回転角 */

  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  glLoadIdentity();

  /* 視点位置と視線方向 */
  gluLookAt(3.0, 4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);

  /* 図形の回転 */
  glRotated((double)r, 0.0, 1.0, 0.0);

  /* 図形の描画 */
  glBegin(GL_QUADS);
  for (j = 0; j &lt; 6; ++j) {
    glColor3dv(color[j]);
    for (i = 0; i &lt; 4; ++i) {
      glVertex3dv(vertex[face[j][i]]);
    }
  }
  glEnd();

  glutSwapBuffers();

  /* 一周回ったら回転角を 0 に戻す */
  if (++r &gt;= 360) r = 0;
}

void resize(int w, int h)
{
  /* 変更なし */
}

void mouse(int button, int state, int x, int y)
{
  /* 変更なし */
}
  
void keyboard(unsigned char key, int x, int y)
{
  /* 変更なし */
}

void init(void)
{
  glClearColor(1.0, 1.0, 1.0, 1.0);

  glEnable(GL_DEPTH_TEST);

  <em>glEnable(GL_CULL_FACE);</em>
  <em>glCullFace(GL_BACK);</em>
}

int main(int argc, char *argv[])
{
  /* 変更なし */
}</pre>

<p>このプログラムも,
多分妙な表示になります.
裏側の面を表示しないはずなのに,
実際は表側の面が削除されています.
実は, 面の表裏は頂点をたどる順番で決定しています.
配列 face[] ではこれを右回り (時計回り) で結んでいます.
ところが OpenGL では,
標準では視点から見て頂点が左回りになっているとき,
その面を表として扱います.
試しに glCullFace(GL_FRONT) としてみてください.
あるいは, face[] において頂点を右回りにたどるようにしてみてください.</p>

<p>なお, 頂点が右回りになっているときを表として扱いたいときは,
glFrontFace(GL_CW) を実行します.
左回りに戻すには glFrontFace(GL_CCW) を実行します.</p>

<p>一般にカリングはクリッピングや隠面消去処理の効率を上げるために,
視野外にある図形など見えないことが分かっているものを事前に取り除いておいて,
隠面消去処理 (可視判定) の対象から外しておくことを言います.
これには様々な方法が存在しますが, glCullFace()
による方法 (背面ポリゴンの除去) は, そのもっとも基本的なものです.</p>

<h2><a class="label" name="11">１１．陰影付け</a></h2>

<h3><a class="label" name="11.1">１１．１ 光を当ててみる</a></h3>

<p>次は面ごとに色を付けるかわりに, 光を当ててみましょう.
陰影付け (光源の処理) の計算を行うためには,
面ごとの色の代わりに法線ベクトルを与えます.
glColor3dv() のかわりに glNormal3dv() を使います.</p>

<pre class="source">GLdouble normal[][3] = {
  { 0.0, 0.0,-1.0 },
  { 1.0, 0.0, 0.0 },
  { 0.0, 0.0, 1.0 },
  {-1.0, 0.0, 0.0 },
  { 0.0,-1.0, 0.0 },
  { 0.0, 1.0, 0.0 }
};</pre>

<p>光を当てるためには, もちろん光源も設定する必要があります.
OpenGL には, 最初からいくつかの光源が用意されています.
いくつの光源が用意されているかはシステムによって異なります.
０番目の光源 (GL_LIGHT0 - 必ず用意されている) を有効にする
(点灯する) には glEnable(GL_LIGHT0),
無効にする (消灯する) には glDisable(GL_LIGHT0) を実行します.</p>

<p>陰影付けを行うと, 陰影付けを行わないより処理速度は低下します.
陰影付けを有効にするには glEnable(GL_LIGHTING),
無効にするには glDisable(GL_LIGHTING) を実行します.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

GLdouble vertex[][3] = {
  /* 変更なし */
};

int face[][4] = {
  /* 変更なし */
};

<em>GLdouble normal[][3] = {
  { 0.0, 0.0,-1.0 },
  { 1.0, 0.0, 0.0 },
  { 0.0, 0.0, 1.0 },
  {-1.0, 0.0, 0.0 },
  { 0.0,-1.0, 0.0 },
  { 0.0, 1.0, 0.0 }
};</em>

void idle(void)
{
  /* 変更なし */
}

void display(void)
{
  int i;
  int j;
  static int r = 0; /* 回転角 */

  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  glLoadIdentity();

  /* 視点位置と視線方向 */
  gluLookAt(3.0, 4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);

  /* 図形の回転 */
  glRotated((double)r, 0.0, 1.0, 0.0);

  /* 図形の描画 */
  glBegin(GL_QUADS);
  for (j = 0; j &lt; 6; ++j) {
    <em>glNormal3dv(normal[j]);</em>
    for (i = 0; i &lt; 4; ++i) {
      glVertex3dv(vertex[face[j][i]]);
    }
  }
  glEnd();

  glutSwapBuffers();

  /* 一周回ったら回転角を 0 に戻す */
  if (++r &gt;= 360) r = 0;
}

void resize(int w, int h)
{
  /* 変更なし */
}

void mouse(int button, int state, int x, int y)
{
  /* 変更なし */
}
  
void keyboard(unsigned char key, int x, int y)
{
  /* 変更なし */
}

void init(void)
{
  glClearColor(1.0, 1.0, 1.0, 1.0);

  glEnable(GL_DEPTH_TEST);

  glEnable(GL_CULL_FACE);
  glCullFace(<em>GL_FRONT</em>);

  <em>glEnable(GL_LIGHTING);</em>
  <em>glEnable(GL_LIGHT0);</em>
}

int main(int argc, char *argv[])
{
  /* 変更なし */
}</pre>

<p><a class="label" name="lighting">なお, 陰影付けが有効になっているときは, </a>
glColor3d() などによる色指定は無視されます.
glColor3d() などで色を付けたいときは, 一旦
glDisable(GL_LIGHTING)
を実行して陰影付けを行わないようにする必要があります.
一方, 上のプログラムのように常に陰影付けを行う場合や,
光源を点灯したままにしておく場合は,
<a href="#depthtest">glEnable(GL_DEPTH_TEST)</a>
同様 glEnalbe(GL_LIGHTING) や glEnable(GL_LIGHT<i>n</i>)
を init() の中で一度実行するだけで十分です.
また, このときは glDisable(GL_LIGHTING) や glDisable(GL_LIGHT<i>n</i>)
を実行する必要はありません.</p>

<h3><a class="label" name="11.2">１１．２ 光源を設定する</a></h3>

<p>それでは光源を二つにして,
それぞれの位置と色を変えてみましょう.
最初の光源 (GL_LIGHT0) の位置を Z 軸方向の斜め上
(0, 3, 5) に, 二つ目の光源 (GL_LIGHT1) を x 軸方向の斜め上
(5, 3, 0) に置き, 二つ目の光源の色を緑 (0, 1, 0) にします.
これらのデータはいずれも四つの要素を持つ GLfloat 型の配列に格納します.
四つ目の要素は 1 にしておいてください.</p>

<pre class="source">GLfloat light0pos[] = { 0.0, 3.0, 5.0, 1.0 };
GLfloat light1pos[] = { 5.0, 3.0, 0.0, 1.0 };
GLfloat green[] = { 0.0, 1.0, 0.0, 1.0 };</pre>

<p>これらを glLightfv() を使ってそれぞれの光源に設定します.
prog2.c を以下のように変更してください.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

GLdouble vertex[][3] = {
  /* 変更なし */
};

int face[][4] = {
  /* 変更なし */
};

GLdouble normal[][3] = {
  /* 変更なし */
};

<em>GLfloat light0pos[] = { 0.0, 3.0, 5.0, 1.0 };</em>
<em>GLfloat light1pos[] = { 5.0, 3.0, 0.0, 1.0 };</em>

<em>GLfloat green[] = { 0.0, 1.0, 0.0, 1.0 };</em>

void idle(void)
{
  /* 変更なし */
}

void display(void)
{
  int i;
  int j;
  static int r = 0; /* 回転角 */

  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  glLoadIdentity();

  /* 視点位置と視線方向 */
  gluLookAt(3.0, 4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);

  <em>/* 光源の位置設定 */</em>
  <em>glLightfv(GL_LIGHT0, GL_POSITION, light0pos);</em>
  <em>glLightfv(GL_LIGHT1, GL_POSITION, light1pos);</em>

  /* 図形の回転 */
  glRotated((double)r, 0.0, 1.0, 0.0);

  /* 図形の描画 */
  glBegin(GL_QUADS);
  for (j = 0; j &lt; 6; ++j) {
    glNormal3dv(normal[j]);
    for (i = 0; i &lt; 4; ++i) {
      glVertex3dv(vertex[face[j][i]]);
    }
  }
  glEnd();

  glutSwapBuffers();

  /* 一周回ったら回転角を 0 に戻す */
  if (++r &gt;= 360) r = 0;
}

void resize(int w, int h)
{
  /* 変更なし */
}

void mouse(int button, int state, int x, int y)
{
  /* 変更なし */
}
  
void keyboard(unsigned char key, int x, int y)
{
  /* 変更なし */
}

void init(void)
{
  glClearColor(1.0, 1.0, 1.0, 1.0);

  glEnable(GL_DEPTH_TEST);

  glEnable(GL_CULL_FACE);
  glCullFace(GL_FRONT);

  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  <em>glEnable(GL_LIGHT1);</em>
  <em>glLightfv(GL_LIGHT1, GL_DIFFUSE, green);</em>
  <em>glLightfv(GL_LIGHT1, GL_SPECULAR, green);</em>
}

int main(int argc, char *argv[])
{
  /* 変更なし */
}</pre>

<dl>

<dt><code>void glLightfv(GLenum light, GLenum pname, const GLfloat *params)</code></dt>

<dd>光源のパラメータを設定します. 最初の引数 light には設定する光源の番号
(GL_LIGHT0〜GL_LIGHT<i>n</i>, <i>n</i> はシステムによって異なります) です.
二つ目の引数 pname は設定するパラメータの種類です.
ここに GL_POSITION を指定すると光源の位置を設定します.
また GL_DIFFUSE を指定すると光源の拡散反射光強度 (色) を設定します.
最後の引数 params は, pname に指定したパラメータの種類に設定する値です.
pname が GL_POSITION あるいは  GL_DIFFUSE のときは,
params は四つの要素を持つ GLfloat 型の配列で,
それぞれ光源の位置および拡散反射光強度を指定します.
光源が (x, y, z) の位置にあるとき,
params の各要素には (x/w, y/w, z/w, w) を設定します.
通常 w = 1 として点光源の位置を設定しますが, w = 0 であれば
(x, y, z) 方向の平行光線の設定になります.
また光源の拡散反射光強度が (R, G, B) なら
params の各要素には (R, G, B, 1) を設定します.
なお, この初期値は (1 1 1 1) ですが, RGB には 1 を越えた値を設定できます.</dd>
</dl>

<p>陰影付けの計算はワールド座標系で行われるので,
glLightfv() による光源の位置 (GL_POSITION) の設定は,
<strong>視点の位置を設定した後に行う</strong>必要があります.
また, 上のプログラムの glRotate3d() より後でこれを設定すると,
光源もいっしょに回転してしまいます.</p>

<ul>
<li><a href="libglut3.html#viewpipe">座標変換のプロセス</a>は
&quot;モデリング変換&rarr;ビューイング変換&rarr;透視変換&rarr;&#133;&quot;
という順に行われると書きましたが,
プログラムのコーディング上は,
これらの設定が<strong>逆順になる</strong>ことに注意してください．
<ol>
<li>glLoadIdentity() でモデルビュー変換行列を初期化</li>
<li>gluLookAt() 等でビューイング変換を設定</li>
<li>glTranslated() や glRotated() 等でモデリング変換を設定</li>
<li>glBegin()〜glEnd() 等による描画</li>
</ol></li>
<li>1-2 の間で光源の位置を設定した場合は,
光源は視点と一緒に移動します.
このとき, 光源の方向を (0, 0, -1, 0),
すなわち Z 軸の負の方向に設定すれば,
自動車のヘッドライトのような効果を得ることができます．</li>
<li>2-3 の間で光源の位置を設定した場合は,
光源の位置は視点や図形の位置によらず固定になります.
通常はここで光源の位置を設定します.</li>
<li>3-4 の間で光源の位置を設定した場合は,
光源の位置は図形と一緒に移動します.</li>
</ul>

<p>glLightfv() による光源の色の設定 (GL_DIFFUSE 等) は,
必ずしも display() 内に置く必要はありません.
プログラムの実行中に光源の色を変更しないなら,
<a href="#depthtest">glEnable(GL_DEPTH_TEST)</a>
や <a href="#lighting">glEnable(GL_LIGHTING)</a>
同様 init() の中で一度実行すれば十分です.</p>

<p>glLightf*() で設定可能なパラメータは,
GL_POSITION や GL_DIFFUSE 以外にもたくさんあります.
光源を方向を持ったスポットライトとし,
その方向や広がり, 減衰率なども設定することもできます.
詳しくは man glLightf を参照してください.</p>

<h3><a class="label" name="11.3">１１．３ 材質を設定する</a></h3>

<p>前の例では図形に色を付けていませんでしたから,
立方体はデフォルトの色 (白) で表示されたと思います.
今度はこの色を変えてみましょう.
この場合も光源の時と同様に四つの要素を持つ GLfloat 型の配列を用意し,
個々の要素に色を R, G, B それに A の順に格納します.
四つ目の要素 (A) は, ここではとりあえず 1 にしておいてください.</p>

<pre class="source">GLfloat red[] = { 0.8, 0.2, 0.2, 1.0 };</pre>

<p>glColor*() で色を付けるときと同様,
図形を描く前に glMaterialfv() を使ってこの色を図形の色に指定します.
prog2.c を以下のように変更してください.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

GLdouble vertex[][3] = {
  /* 変更なし */
};

int face[][4] = {
  /* 変更なし */
};

GLdouble normal[][3] = {
  /* 変更なし */
};

GLfloat light0pos[] = { 0.0, 3.0, 5.0, 1.0 };
GLfloat light1pos[] = { 5.0, 3.0, 0.0, 1.0 };

GLfloat green[] = { 0.0, 1.0, 0.0, 1.0 };
<em>GLfloat red[] = { 0.8, 0.2, 0.2, 1.0 };</em>

void idle(void)
{
  /* 変更なし */
}

void display(void)
{
  int i;
  int j;
  static int r = 0; /* 回転角 */

  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  glLoadIdentity();

  /* 視点位置と視線方向 */
  gluLookAt(3.0, 4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);

  /* 光源の位置設定 */
  glLightfv(GL_LIGHT0, GL_POSITION, light0pos);
  glLightfv(GL_LIGHT1, GL_POSITION, light1pos);

  /* 図形の回転 */
  glRotated((double)r, 0.0, 1.0, 0.0);

  <em>/* 図形の色 (赤)  */</em>
  <em>glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, red);</em>

  /* 図形の描画 */
  glBegin(GL_QUADS);
  for (j = 0; j &lt; 6; ++j) {
    glNormal3dv(normal[j]);
    for (i = 0; i &lt; 4; ++i) {
      glVertex3dv(vertex[face[j][i]]);
    }
  }
  glEnd();

  glutSwapBuffers();

  /* 一周回ったら回転角を 0 に戻す */
  if (++r &gt;= 360) r = 0;
}

void resize(int w, int h)
{
  /* 変更なし */
}

void mouse(int button, int state, int x, int y)
{
  /* 変更なし */
}
  
void keyboard(unsigned char key, int x, int y)
{
  /* 変更なし */
}

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  /* 変更なし */
}</pre>

<dl>

<dt><code>void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)</code></dt>

<dd>glMaterialfv() は図形の材質パラメータを設定します.
引数 face には GL_FRONT, GL_BACK および GL_FRONT_AND_BACK が指定でき,
それぞれ面の表, 裏, あるいは両面に材質パラメータを設定します.
設定できる材質 pname には GL_AMBIENT (環境光に対する反射係数),
GL_DIFFUSE (拡散反射係数), GL_SPECULAR (鏡面反射係数),
GL_EMISSION (発光係数), GL_SHININESS (ハイライトの輝き),
あるいは GL_AMBIENT_AND_DIFFUSE (拡散反射係数と鏡面反射係数の両方) 
があります. 他にインデックスカラーモード (GLUT_INDEX) であれば
GL_COLOR_INDEXES も使用できますが,
この資料では使用していません.
引数 params は一つまたは四つの要素を持つ GLfloat 型 (float と等価) の配列で,
四つの要素を持つ場合 (GL_SHININESS, GL_COLOR_INDEXES 以外) は,
色の成分 RGB および A に対する係数を指定します.
この初期値は (0.8, 0.8, 0.8, 1) ですが,
1 を越える値も設定できます.</dd>

</dl>

<p>図形に色を付けるということは,
図形の物理的な材質パラメータを設定することに他なりません.
<strong>GL_DIFFUSE で設定する拡散反射係数が図形の色</strong>に相当します.
GL_AMBIENT は環境光 (光源以外からの光) に対する反射係数で,
光の当たらない部分の明るさに影響を与えます.
GL_DIFFUSE と GL_AMBIENT には同じ値を設定することが多いので,
これらを同時に設定する GL_AMBIENT_AND_DIFFUSE が用意されています.
GL_SPECULAR は光源に対する鏡面反射係数で,
図形表面の光源の映り込み (ハイライト) の強さです.
GL_SHININESS はこの鏡面反射の細さを示し,
大きいほどハイライトの部分が小さくなります.
この材質パラメータの要素は一つだけなので,
glMaterialf() を使って設定することもできます.</p>

<p>GL_DIFFUSE 以外のパラメータを設定することによって,
図形の質感を制御できます.
たとえば GL_SPECULAR (鏡面反射係数) を白 (1 1 1 1)
に設定して GL_SHININESS を大きく (10〜40 とか／最大 128) すれば
つややかなプラスチックのようになりますし,
GL_SPECULAR (鏡面反射係数) を GL_DIFFUSE と同じにして
GL_AMBIENT を 0 に近づければ金属的な質感になります.
ただし GL_SPECULAR や GL_AMBIENT を操作するときは,
glLightfv() で光源のこれらのパラメータも設定してやる必要があります.</p>

<h2><a class="label" name="12">１２．階層構造</a></h2>

<p>次に図形の階層構造を表現してみます.
これまでのプログラムで実際に立方体を描いている部分を,
独立した関数 cube() として抜き出します.
また,
このプログラムでは視点の位置や画角などは変更しないので,
これをウィンドウを開いたりサイズが変更されたときに設定するようにします.</p>

<p>こうすると変換行列は glRotated() で変更されたあと元に戻されないため,
このままでは次に描画するときにはおかしくなってしまいます.
そこで, glRoatated() を使う前に,
そのときの変換行列の内容を保存しておき,
あとでその内容を戻します.
現在の変換行列を保存するには glPushMatrix(),
保存した変換行列を復帰するには glPopMatrix() を使います.
prog2.c を以下のように変更してください.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

GLdouble vertex[][3] = {
  /* 変更なし */
};

int face[][4] = {
  /* 変更なし */
};

GLdouble normal[][3] = {
  /* 変更なし */
};

GLfloat light0pos[] = { 0.0, 3.0, 5.0, 1.0 };
GLfloat light1pos[] = { 5.0, 3.0, 0.0, 1.0 };

GLfloat green[] = { 0.0, 1.0, 0.0, 1.0 };
GLfloat red[] = { 0.8, 0.2, 0.2, 1.0 };

<em>void cube(void)
{
  int i;
  int j;

  glBegin(GL_QUADS);
  for (j = 0; j &lt; 6; ++j) {
    glNormal3dv(normal[j]);
    for (i = 0; i &lt; 4; ++i) {
      glVertex3dv(vertex[face[j][i]]);
    }
  }
  glEnd();
}</em>

void idle(void)
{
  /* 変更なし */
}

void display(void)
{
  static int r = 0; /* 回転角 */

  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  /* 光源の位置設定 */
  glLightfv(GL_LIGHT0, GL_POSITION, light0pos);
  glLightfv(GL_LIGHT1, GL_POSITION, light1pos);

  <em>/* モデルビュー変換行列の保存 */</em>
  <em>glPushMatrix();</em>

  /* 図形の回転 */
  glRotated((double)r, 0.0, 1.0, 0.0);

  /* 図形の色 (赤)  */
  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, red);

  /* 図形の描画 */
  <em>cube();</em>

  <em>/* モデルビュー変換行列の復帰 */</em>
  <em>glPopMatrix();</em>

  glutSwapBuffers();

  /* 一周回ったら回転角を 0 に戻す */
  if (++r &gt;= 360) r = 0;
}

void resize(int w, int h)
{
  glViewport(0, 0, w, h);

  /* 透視変換行列の設定 */
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(30.0, (double)w / (double)h, 1.0, 100.0);

  /* モデルビュー変換行列の設定 */
  glMatrixMode(GL_MODELVIEW);
  <em>glLoadIdentity();</em>
  <em>gluLookAt(3.0, 4.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);</em>
}

void mouse(int button, int state, int x, int y)
{
  /* 変更なし */
}
  
void keyboard(unsigned char key, int x, int y)
{
  /* 変更なし */
}

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  /* 変更なし */
}</pre>

<p>この図形に, もう一つ立方体を追加します.
二つ目の cube() を実行する前に glTranslated() を実行して,
最初の cube() の位置から少しずらします.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

GLdouble vertex[][3] = {
  /* 変更なし */
};

int face[][4] = {
  /* 変更なし */
};

GLdouble normal[][3] = {
  /* 変更なし */
};

GLfloat light0pos[] = { 0.0, 3.0, 5.0, 1.0 };
GLfloat light1pos[] = { 5.0, 3.0, 0.0, 1.0 };

GLfloat green[] = { 0.0, 1.0, 0.0, 1.0 };
GLfloat red[] = { 0.8, 0.2, 0.2, 1.0 };

void cube(void)
{
  /* 変更なし */
}

void idle(void)
{
  /* 変更なし */
}

void display(void)
{
  static int r = 0; /* 回転角 */

  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  /* 光源の位置設定 */
  glLightfv(GL_LIGHT0, GL_POSITION, light0pos);
  glLightfv(GL_LIGHT1, GL_POSITION, light1pos);

  /* モデルビュー変換行列の保存 */
  glPushMatrix();

  /* 図形の回転 */
  glRotated((double)r, 0.0, 1.0, 0.0);

  /* 図形の色 (赤) */
  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, red);

  /* 図形の描画 */
  cube();

  <em>/* 二つ目の図形の描画 */</em>
  <em>glPushMatrix();</em>
  <em>glTranslated(1.0, 1.0, 1.0);</em>
  <em>cube();</em>
  <em>glPopMatrix();</em>

  /* モデルビュー変換行列の復帰 */
  glPopMatrix();

  glutSwapBuffers();

  /* 一周回ったら回転角を 0 に戻す */
  if (++r &gt;= 360) r = 0;
}

void resize(int w, int h)
{
  /* 変更なし */
}

void mouse(int button, int state, int x, int y)
{
  /* 変更なし */
}
  
void keyboard(unsigned char key, int x, int y)
{
  /* 変更なし */
}

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  /* 変更なし */
}</pre>

<p>このように変換行列に変更を加えている部分を
glPushMatrix() と glPopMatrix() の対ではさんで「入れ子構造」にすることによって,
動きの階層構造を表現できます.</p>

<p>なお, この例では二つ目の cube() より後ろでは何も描画しておらず,
最後の glPushMatrix() で最初に実行した glPushMatrix()
で保存した内容を復帰しているため,
この cube() をはさんでいる glPushMatrix() と glPopMatrix()
は無くても結果は変わりません.</p>

<p>ではこの二つ目の cube() を, 一つ目の cube()
の倍の速度で回転させてみましょう.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

GLdouble vertex[][3] = {
  /* 変更なし */
};

int face[][4] = {
  /* 変更なし */
};

GLdouble normal[][3] = {
  /* 変更なし */
};

GLfloat light0pos[] = { 0.0, 3.0, 5.0, 1.0 };
GLfloat light1pos[] = { 5.0, 3.0, 0.0, 1.0 };

GLfloat green[] = { 0.0, 1.0, 0.0, 1.0 };
GLfloat red[] = { 0.8, 0.2, 0.2, 1.0 };

void cube(void)
{
  /* 変更なし */
}

void idle(void)
{
  /* 変更なし */
}

void display(void)
{
  static int r = 0; /* 回転角 */

  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  /* 光源の位置設定 */
  glLightfv(GL_LIGHT0, GL_POSITION, light0pos);
  glLightfv(GL_LIGHT1, GL_POSITION, light1pos);

  /* モデルビュー変換行列の保存 */
  glPushMatrix();

  /* 図形の回転 */
  glRotated((double)r, 0.0, 1.0, 0.0);

  /* 図形の色 (赤) */
  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, red);

  /* 図形の描画 */
  cube();

  /* 二つ目の図形の描画 */
  glPushMatrix();
  glTranslated(1.0, 1.0, 1.0);
  <em>glRotated((double)(2 * r), 0.0, 1.0, 0.0);</em>
  cube();
  glPopMatrix();

  /* モデルビュー変換行列の復帰 */
  glPopMatrix();

  glutSwapBuffers();

  /* 一周回ったら回転角を 0 に戻す */
  if (++r &gt;= 360) r = 0;
}

void resize(int w, int h)
{
  /* 変更なし */
}

void mouse(int button, int state, int x, int y)
{
  /* 変更なし */
}
  
void keyboard(unsigned char key, int x, int y)
{
  /* 変更なし */
}

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  /* 変更なし */
}</pre>

<p>この例では, 一つ目の glRotated() による回転が
両方の cube() に影響しているのに対し,
二つ目の glRotated() は二つ目の cube() にしか影響していません.
これによって, 図形の動きの階層構造を表現できます.
では最後に, この二つの立方体の色を変えてみましょう.</p>

<pre class="source">#include &lt;GL/glut.h&gt;

GLdouble vertex[][3] = {
  /* 変更なし */
};

int face[][4] = {
  /* 変更なし */
};

GLdouble normal[][3] = {
  /* 変更なし */
};

GLfloat light0pos[] = { 0.0, 3.0, 5.0, 1.0 };
GLfloat light1pos[] = { 5.0, 3.0, 0.0, 1.0 };

GLfloat green[] = { 0.0, 1.0, 0.0, 1.0 };
GLfloat red[] = { 0.8, 0.2, 0.2, 1.0 };
<em>GLfloat blue[] = { 0.2, 0.2, 0.8, 1.0 };</em>

void cube(void)
{
  /* 変更なし */
}

void idle(void)
{
  /* 変更なし */
}

void display(void)
{
  static int r = 0; /* 回転角 */

  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  /* 光源の位置設定 */
  glLightfv(GL_LIGHT0, GL_POSITION, light0pos);
  glLightfv(GL_LIGHT1, GL_POSITION, light1pos);

  /* モデルビュー変換行列の保存 */
  glPushMatrix();

  /* 図形の回転 */
  glRotated((double)r, 0.0, 1.0, 0.0);

  /* 図形の色 (赤) */
  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, red);

  /* 図形の描画 */
  cube();

  /* 二つ目の図形の描画 */
  glPushMatrix();
  glTranslated(1.0, 1.0, 1.0);
  glRotated((double)(2 * r), 0.0, 1.0, 0.0);
  <em>glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, blue);</em>
  cube();
  glPopMatrix();

  /* モデルビュー変換行列の復帰 */
  glPopMatrix();

  glutSwapBuffers();

  /* 一周回ったら回転角を 0 に戻す */
  if (++r &gt;= 360) r = 0;
}

void resize(int w, int h)
{
  /* 変更なし */
}

void mouse(int button, int state, int x, int y)
{
  /* 変更なし */
}
  
void keyboard(unsigned char key, int x, int y)
{
  /* 変更なし */
}

void init(void)
{
  /* 変更なし */
}

int main(int argc, char *argv[])
{
  /* 変更なし */
}</pre>

<h2><a class="label" name="ex1">実験１．基本実験</a></h2>

<p>ここからようやく実験の本題に入ります.
以下のテーマのうち, グループに割り当てられた課題を選んで実験してください.
これまでのようにソースプログラムは明示しませんから,
自分で実装を考えてください.</p>

<ul>
<li><a href="ex-a.html">ウォークスルーの実験</a> (Ａグループ)</li>
<li><a href="ex-b.html">ロボットアームの実験</a> (Ｂグループ)</li>
<li><a href="ex-c.html">ピッチングマシーンの実験</a> (Ｃグループ)</li>
<li><a href="ex-d.html">ラジコンティーポットの実験</a> (Ｄグループ)</li>
<li><a href="ex-e.html">歩行ロボットの実験</a> (予備)</li>
<li><a href="ex-f.html">エアホッケーの実験</a> (予備)</li>
<li><a href="ex-g.html">観覧車の実験</a>（予備）</li>
<li><a href="ex-h.html">ビー玉の実験</a>（予備）</li>
</ul>

<h2><a class="label" name="ex2">実験２．立体視の実験</a></h2>

<h3>立体視のメカニズム</h3>

<p>人間が映像から立体感（奥行き）を知覚する要因には<a href="depth.m4v">様々なもの</a>がありますが,
その中のひとつに<em>両眼視差</em>があります.
これは１つの対象を見るときでも右目と左目では見る角度が微妙に異なるため,
それぞれの目の網膜に映る映像に違いが発生して,
そこから奥行きを知覚する現象です.</p>

<div class="figure"><img src="parallax.gif" width="122" height="194"
alt="視差による網膜像の違い"></div>

<p>これをテレビやコンピュータのディスプレイを使って再現するには,
<em>右目と左目に別々の映像を見せる仕組み</em>が必要になります.
これにはヘッドマウンティッドディスプレイ (HMD) などのように右目と左目の直前に独立したディスプレイを置く方式や,
液晶シャッタメガネを使う時分割方式,
偏光メガネ方式,
メガネを必要としない裸眼方式など,
いくつかの方式があります．</p>

<p>実験１で作成したプログラムをもとにして,
両眼視差による立体視 (ステレオ表示) を行うプログラムを作成してください.
使用する実験機器に応じて,
以下の<em>いずれかの方式</em>でプログラムを作成してください.</p>

<ul>
<li><a href="linebyline.html">偏光メガネ (ラインバイライン方式) を用いた立体視の実現</a></li>
<li><a href="3dlcd.html">裸眼 3D ディスプレイ (SHARP LL-151D) を用いた立体視の実現</a></li>
<li><a href="quadbuffer.html">液晶シャッタメガネ (時分割方式) を用いた立体視の実現</a></li>
</ul>

<h2><a class="label" name="ex3">実験３．自由課題</a></h2>
<p>OpenGL と GLUT を使って，<em>立体視ディスプレイを活用した</em>ゲームなど（シューティング，レース，格闘，落ちもの等何でも）何か「動く」プログラムを作成してください．実験１・２のプログラムを拡張したものでも構いません．</p>
<!--
<h2><a class="label" name="ex3">実験３．仮想のぞき穴の実験</a></h2>

<p>ディスプレイをのぞき穴に見立てて,
その向こう側に仮想的な部屋があるものとして画像を生成します.
観測者の頭に位置センサ (IsoTrak) を取り付け,
その情報を元に画像を生成することにより,
運動視差による奥行き感を実現します.
IsoTrak からのデータの読み込みについては,
<a href="isotrak/">IsoTrak II の資料</a>を参照してください.</p>

<h2><a class="label" name="ex4">実験４．仮想パペットの実験</a></h2>

<p>SuperGrove から得られるデータを元に,
ＣＧ指人形を動かします.
SuperGrove からのデータの読み込みについては,
<a href="superglovejr/">SupreGlove Jr. の資料</a>を参照してください.
なお, この実験は表示形状を変化させることになるので,
ディスプレイリストは使わない方が簡単だと思います.</p>

<h2><a class="label" name="ex5">実験５．仮想パンチングボールの実験</a></h2>

<p>Crystal Eys を装着し, IsoTrak のセンサを握り締めて,
パンチングボールを殴ります.
IsoTrak からのデータの読み込みについては,
<a href="isotrak/">IsoTrak II の資料</a>を参照してください.</p>
-->
</body>
</html>
